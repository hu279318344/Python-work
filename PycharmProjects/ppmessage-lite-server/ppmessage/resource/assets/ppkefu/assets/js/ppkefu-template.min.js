window.ppmessage = {
    "version": "3.0.0",
    "developer_mode": false,
    "api_key": "{{api_key}}",
    "server_url": "{{server_url}}",
    "disableOnbeforeunload": false
};

var ppmessageModule = angular.module("ppmessage", [
    "ionic",
    "base64",
    "blockUI",
    "angularFileUpload",
    "pascalprecht.translate"
]);

ppmessageModule.config([
    "$sceProvider",
    "blockUIConfig",
    "$ionicConfigProvider",
function ($sceProvider, blockUIConfig, $ionicConfigProvider) {
    $sceProvider.enabled(false);

    blockUIConfig.autoBlock = false;
    blockUIConfig.autoInjectBodyBlock = true;

    $ionicConfigProvider.views.maxCache(10);
    $ionicConfigProvider.views.swipeBackEnabled(false);

    $ionicConfigProvider.tabs.position("bottom");
    $ionicConfigProvider.tabs.style("standard");

    $ionicConfigProvider.backButton.text("");
    
}]).run([
    "$state",
    "$timeout",
    "$rootScope",
    "$ionicPlatform",
    "yvSys",
    "yvMenu",
    "yvLocal",
    "yvMonitor",
function ($state, $timeout, $rootScope, $ionicPlatform, yvSys, yvMenu, yvLocal, yvMonitor) {

    yvLocal.localize();
    yvMenu.init();
    
    if (ppmessage.developer_mode) {
        ppmessage.monitor = yvMonitor;
    }

    $rootScope.getAppBodyStyle = function () {
        return yvSys.get_app_body_style();
    };

    $rootScope.getDeviceClass = function () {
        if (yvSys.in_mobile_browser()) {
            return "in-mobile-browser";
        }
        if (yvSys.in_pc_browser()) {
            return "in-pc-browser";
        }
    };

    $ionicPlatform.ready(function () {
    });

}]).constant("$ionicLoadingConfig", {
    // delay: 100,
    // duration: 5000,
    noBackdrop: true,
    hideOnStateChange: true,
    template: "<ion-spinner></ion-spinner>"
});

ppmessageModule.config([
    "$stateProvider",
    "$urlRouterProvider",
function ($stateProvider, $urlRouterProvider) {

    $stateProvider

        .state("main-with-logo", {
            cache: false,
            controller: "MainWithLogoCtrl",
            url: "/main-with-logo",
            templateUrl: "templates/controllers/noapp.main-with-logo.html"
        })

        .state("noapp", {
            abstract: true,
            controller: "NoAppCtrl",
            url: "/noapp",
            templateUrl: "templates/controllers/noapp.html"
        })

        .state("noapp.login-error", {
            cache: false,
            controller: "LoginErrorCtrl",
            url: "/login-error",
            templateUrl: "templates/controllers/noapp.login-error.html"
        })

        .state("noapp.auto-login", {
            cache: false,
            controller: "AutoLoginCtrl",
            url: "/auto-login/:request_body",
            templateUrl: "templates/controllers/noapp.auto-login.html"
        })

        .state("noapp.login-no-user", {
            controller: "LoginNoUserCtrl",
            url: "/login-no-user",
            templateUrl: "templates/controllers/noapp.login-no-user.html"
        })

        .state("noapp.login-with-user", {
            controller: "LoginWithUserCtrl",
            url: "/login-with-user/",
            templateUrl: "templates/controllers/noapp.login-with-user.html",
            params: {email: null, fullname: null, icon: null}
        })


        .state("app", {
            abstract: true,
            url: "/app",
            templateUrl: "templates/controllers/app.html",
            controller: "AppCtrl"
        })

        .state("app.conversation-list", {
            url: "/conversation-list",
            views: {
                "app-conversation-list": {
                    templateUrl: "templates/controllers/app.conversation-list.html",
                    controller: "ConversationListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.conversation.html",
                    controller: "ConversationCtrl"
                }
            },
            params: {conv_uuid: null, conv_type: null, conv_name: null}
        })


        .state("app.setting-list", {
            url: "/setting-list",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.blank-setting.html",
                }
            }
        })

        .state("app.change-avatar", {
            url: "/change-avatar",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.change-avatar.html",
                    controller: "ChangeAvatarCtrl"
                }
            }
        })

        .state("app.change-password", {
            url: "/change-password",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.change-password.html",
                    controller: "ChangePasswordCtrl"
                }
            }
        })


        .state("app.change-fullname", {
            url: "/change-fullname",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.change-fullname.html",
                    controller: "ChangeFullnameCtrl"
                }
            }
        })

        .state("app.change-signature", {
            url: "/change-signature",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.change-signature.html",
                    controller: "ChangeSignatureCtrl"
                }
            }
        })

    
        .state("app.developer-keys", {
            url: "/developer-keys",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.developer-keys.html",
                    controller: "DeveloperKeysCtrl"
                }
            }
        })


        .state("app.widget-code", {
            url: "/widget-code",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.widget-code.html",
                    controller: "WidgetCodeCtrl"
                }
            }
        })

    
        .state("app.widget-link", {
            url: "/widget-link",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.widget-link.html",
                    controller: "WidgetLinkCtrl"
                }
            }
        })

        .state("app.switch-language", {
            url: "/switch-language",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.switch-language.html",
                    controller: "SwitchLanguageCtrl"
                }
            }
        })

        .state("app.about", {
            cache: false,
            url: "/about",
            views: {
                "app-setting-list": {
                    templateUrl: "templates/controllers/app.setting-list.html",
                    controller: "SettingListCtrl"
                },
                "side-menu-content": {
                    templateUrl: "templates/controllers/app.about.html",
                    controller: "AboutCtrl"
                }
            }
        })

    $urlRouterProvider.otherwise("/main-with-logo");

}]);

ppmessageModule.config([
    "$translateProvider",
    "yvTransTags",
    function ($translateProvider, yvTransTags) {
        $translateProvider.useSanitizeValueStrategy('escape');
        $translateProvider.translations("en", yvTransTags.en);
        $translateProvider.translations("zh-CN", yvTransTags.cn);
        $translateProvider.registerAvailableLanguageKeys(["en", "zh-CN"], {
            "en": "en",
            "en-US": "en",
            "en-UK": "en",
            "zh-CN": "zh-CN",
            "zh_CN": "zh-CN",
            "zh-cn": "zh-CN",
            "zh-Hans": "zh-CN"
        });
        $translateProvider.fallbackLanguage("en", "zh-CN");
    }

]).constant("yvTransTags", {

    en: {
        noapp: {
            LOGIN_TAG: "Log In",
            USERNAME_TAG: "Username",
            USEREMAIL_TAG: "User email",
            PASSWORD_TAG: "Password",
            LOGIN_CANCEL_TAG: "Cancel",
            
            loginWithUser: {
                LOGIN_TAG: "Log In",
                LOGIN_PASSWORD_TAG: "Password",
                SWITCH_USER_TAG: "Switch User"
            }
        },

        app: {
            common: {
                SAVE_TAG: "Save",
                RESTORE_TAG: "Restore",
                CANCEL_TAG: "Cancel",
                OK_TAG: "OK",
                BACK_TAG: "Back"
            },
            settings: {
                SETTINGS_TAG: "Settings",
                LOG_OUT_TAG: "Log Out",
                APPLICATION_TAG: "App",
                profile_photo: {
                    LOADING_TAG: "Loading image...",
                    PROFILE_PHOTO_TAG: "Profile Photo",
                    TAKE_PHOTO_TAG: "Take Photo",
                    CHOOSE_FROM_PHOTOS_TAG: "Choose from Photos"
                },
                name: {
                    NAME_TAG: "Name",
                    INPUT_NEW_NAME_TAG: "Please input your new name"
                },

                signature: {
                    SIGNATURE_TAG: "Signature",
                    WRITE_SOMETHING: "Write something"
                },

                password: {
                    PASSWORD_TAG: "Password",
                    INPUT_ORIGIN_PASSWORD_TAG: "Input your original password",
                    INPUT_NEW_PASSWORD_TAG: "Input your new password",
                    INPUT_NEW_PASSWORD_AGAIN_TAG: "Input your new password again"
                },

                widget_code: {
                    WIDGET_CODE_TAG: "Widget Code"
                },

                widget_link: {
                    LOOK_NOW_TAG: "Take a look",
                    WIDGET_LINK_TAG: "Widget Link"
                },

                developer_keys: {
                    DEVELOPER_KEYS_TAG: "Developer Keys"
                },

                language: {
                    LANGUAGE_TAG: "Language",
                    CHINESE_TAG: "中文",
                    ENGLISH_TAG: "English"
                },

                app: {
                    APP_TAG: "App"
                },

                about: {
                    ABOUT_TAG: "About",
                    CANT_GET_NEWEST_VERSION_TAG: "Can't get application version",
                    IS_NEWEST_VERSION_TAG: "Already at latest version",
                    UPGRADE_TO_VERSION_TAG: "Upgrade to version "
                },
                
                integrate: {
                    INTEGRATE_TAG: "Application Integration"
                }
            },
            
            messages: {
                MESSAGE_TAG: "Messages",
                CONVERSATIONS_TAG: "Conversations",
                MARK_AS_READ_TAG: "Mark as read",
                DELETE: "Delete",
                ALL: "All",
                UNASSIGNED: "Unassigned",
                MINE: "Mine"
            },
            
            contact: {
                CONTACT_TAG: "Contacts",
                SERVICE_TAG: "Services",
                SEARCH_TAG: "Search",
                ORGANIZATION_TAG: "Organizations",
                DISCUSSION_TAG: "Discussions",
                NEW_FRIENDS_TAG: "New Friends",
                SERVANT: "Servants",
                CUSTOMER: "Customer"
            },
            
            
            detailInfo: {
                DETAIL_INFO_TAG: "Details",
                FULLNAME_TAG: "Display Name",
                LOGIN_NAME_TAG: "Login Name",
                PROFILE_PHOTO_TAG: "Profile Photo",
                TYPE_TAG: "Type: ",
                MAIL_TAG: "Email",
                IDENTITY_TAG: "Identity",
                BELONG_TO_ORG_TAG: "Superordinate Organizations",
                MESSAGE_HISTORY_TAG: "Message History",
                CHAT_WITH_USER_TAG: "Chat",
                DELETE_USER_TAG: "Remove Contact",
                INVITE_USER_AS_CONTACT_TAG: "Invite as Contact",

                USER_EMAIL: "Email",
                USER_IDENTITY: "Identity",
                USER_EDUCATION: "Education",
                USER_CALENDAR: "School Calendar",
                USER_DEPARTMENT: "Department",
                USER_MAJOR: "Major",
                USER_CLASS: "Class",

                INVITE_CONTACT: "I want to invite you to be my contact."
            },
            
            leftPanel: {
                MESSAGE_TAG: "Messages",
                CONTACTS_TAG: "Contacts",
                SETTINGS_TAG: "Settings"
            },

            messageThread: {
                PULL_TO_LOAD_MORE: "Load More",
                LOGIN_PASSWORD_TAG: "Password",
                OK_TAG: "OK",
                CANCEL_TAG: "Cancel",
                CHOOSE_CONTACTS_TAG: "Choose Contacts",
                SEARCH_CONTACTS_TAG: "Search contacts by keywords",

                SEND: "Send",
                SEND_TIP: "Press Ctrl+Enter to start a new line",
                TEXTAREA_TIP: "Write something...",

                ASSIGN: "Assign",
                TYPE: "Type",
                SERVICE_USER: "Service User",
                PORTAL_USER: "Portal User",
                TOGGLE_FONT_SIZE: "Toggle font size: "
            },

            lockPopover: {
                COPY_TAG: "Copy",
                ENCRYPTOIN_TAG: "Encryption",
                DECRYPTION_TAG: "Decryption",
                DELETE_TAG: "Delete"
            },

            myContacts: {
                SEARCH_HINT_TAG: "Search"
            },

            messageHistory: {
                PULL_TO_LOAD_MORE: "Load More"
            },

            forgetPassword: {
                REGISTER_EMAIL: "Registered email address",
                RESET_PASSWORD: "Reset password"
            },

            chatModal: {
                CHOOSE: "Select",
                CANCEL: "Cancel"
            },

            LOCAL: {

                SAVE_TO_PHONE: "Save to the phone",

                SAVE: "Save",

                CHECK_UPDATE: "Updated to",
                IS_UPDATED: "It's been the latest version",
                GET_VERSION_FAIL: "Could not get the latest version",

                PROMPT_LEAVE: "Are you sure you want to leave?"

            },

            COMMON: {
                ERR_TITLE: "Error",
                INFO_TITLE: "Prompt",
                SET_SUCCESS: "Setting successfully",
                SET_FAILURE: "Setting failed"
            },

            changeiconctrl: {
                SMALL_ICON: "The picture size should not be less than 160 * 160 pixels!"
            },

            changefullnamectrl: {
                FULLNAME_EMPTY: "The name can't be empty",
                FULLNAME_TOO_LARGE: "No more than 32 characters"
            },

            changepwdctrl: {
                PROMPT_EMPTY: "Both the original password and new password can not be empty",
                PROMPT_PWD_ERROR: "Incorrect original password",
                PROMPT_VERIFY_ERROR: "The second input password is different from the first one.",
                PROMPT_SAME_ERROR: "The new password can't be the same as the original password.",
                PROMPT_LENGTH: "No more than 16 characters"
            },

            conversationsctrl: {
                NO_MESSAGE: "There is no messages, slide to the right to view the main menu."
            },

            GLOBAL: {
                ERR_TOKEN: "Can't get access token",
                ERR_NET: "Can't connect to server",
                ERR_LOGIN: "Can't login",
                ERR_USERPASS: "Username or password incorrect",
                ERR_IOSTOKEN: "Failed to get message push identity.",
                ERR_NO_SERVER: "No server is selected !",
                ERR_NO_PASSWORD_EMAIL: "No password and email",
                ERR_NO_ENOUGH_INFO: "Miss parameter to action.",

                NOTIFICATION_CHANGE_SUCCESS: "Notification changed successfully",
                NOTIFICATION_CHANGE_FAIL: "Fail to change Notification",
                NOTIFICATION_TYPE: "Notification Type",
                
                ONLINE: "OnLine",
                OFFLINE: "Offline",
                                
                CANT_GET_MORE_HISTORY_MESSAGES: "Can't get more history messages",
                CANT_GET_MORE_CONVERSATIONS: "Can't get more conversations",
                CANT_REFRESH_CONVERSATIONS: "Can't refresh conversations",
                
                TITLE_FILE:        "File Message",
                TITLE_TEXT:        "Text Message",
                TITLE_IMAGE:       "Image Message",
                TITLE_LOGOUT:      "Logout Message",
                TITLE_UNKNOWN:     "Unknown Message",

                CANT_OPEN_FILE: "Can't open this file",
                
                SHOW_BADGE: "Show Badge",
                SHOW_BADGE_NOTE: "When message arrives, show unread count in App icon",
                MUTE_NOTIFICATION: "Mute Notification",
                MUTE_NOTIFICATION_NOTE: "No notification when message arrives",
                SILENCE_NOTIFICATION: "Silence Notification",
                SILENCE_NOTIFICATION_NOTE: "Only show text notification, no sound alert when new message arrives ",
                MUTE_OTHER_MOBILE_DEVICE: "Mute Notificaiton in Mobile",
                MUTE_OTHER_MOBILE_DEVICE_NOTE: "When login in both Web and mobile device, let mobile device not show notification",
                IS_DISTRIBUTOR_USER: "Set as Distributor",
                IS_DISTRIBUTOR_USER_NOTE: "A distributor can receive messages from any portal user and assign conversations to other service user",
                
                TIMESTAMP_LANGUAGE: "en",
                TIMESTAMP_FORMAT: "MM-DD HH:mm",

                ALERT_OK: "Ok",
                ALERT_CANCEL: "Cancel",
                CLOSE: "Close",
                SAVE: "Save",
                SAVE_PHOTO_SUCCESS: "Successfully save image to albumn",
                SAVE_PHOTO_FAILURE: "Fail to save image to albumn",
                DOWNLOAD_FAILURE: "Request to download fails",
                
                LOGIN_IN_ANOTHER_DEVICE: "Your account has logined in another device",

                FILE: "Files",
                PICTURE: "Pictures",
                CAMERA: "Camera",
                MESSAGE_CONTENT: "Message Content",
                
                CANCEL: "Cancel",
                COPY: "Copy",
                FORWARD: "Forward",
                DELETE: "Delete",
                LOCK: "Lock",
                UNLOCK: "UnLock",

                RELOAD: "Reload",

                SEARCH: "Search",
                YESTERDAY: "Yesterday",
                
                UPDATE_TITLE: "A new version is avaliable!",
                UPDATE_CONTENT1: "Current version is ",
                UPDATE_CONTENT2: ", do you want to upgrade to the latest version",
                UPDATE_CONTENT3: " ?",

                UPDATE_FAILED: "Update failed",
                UPDATE_SUCCESS: "Update successfully",
                
                NO_RECENT_MESSAGE: "No recent message",
                NO_MORE_HISTORY_MESSAGES: "No more history messages",
                
                CHECKING_FILE: "Checking file ...",
                UPLOADING_FILE: "Uploading file ...",
                SENDING: "Sending Message ...",
                CANCELED: "Canceled",                
                TYPING: " is typing ",

                CONVERSATIONS: "Conversations",
                CONTACTS: " Contacts",
                NO_RESULTS: "No results",
                SELECT_APP: "Select a app",
                PRECEED: "Preceed",
                QUIT: "Quit",
                REMEMBER_MY_CHOICE: "Remember my choice",
                NO_CONVERSATION_SELECTED: "No conversation selected",
                NO_CONTACT_SELECTED: "No contact selected",
                NO_SETTING_SELECTED: "No setting item selected",
                NO_CONVERSATION: "No conversation",
                NO_CONTACT: "No contact",
                YOU_DONT_HAVE_ANY_APP: "You don't have any app",
                ON_BEFORE_UNLOAD_WARNING: "You will log out if window is closed.",
                NO_MATCH_RESULTS: "No match results",

                ADD_MEMBER: "Add Member",
                ADD_BY_CONTACT: "Add by Contact",
                ADD_BY_GROUP: "Add by Group",
                
                USER_FULLNAME: "User Fullname",
                USER_PASSWORD: "User Password",
                USER_PASSWORD_REPEAT: "Repeat User Password",
                USER_EMAIL: "User Email",
                ADD_SERVICE_USER: "Add Service User",

                SUBMIT: "Submit",

                REQUIRED_NOT_PROVIDED: "Required not provided",
                PASSWORD_REPEAT_NOT_MATCH: "Password repeat not match",
                PASSWORD_TOO_LONG: "Password too long"

            }
        }
    },

    cn: {
        noapp: {
            LOGIN_TAG: "登录",
            USERNAME_TAG: "用户名",
            USEREMAIL_TAG: "邮箱",
            PASSWORD_TAG: "密码",
            LOGIN_CANCEL_TAG: "取消",
            
            loginWithUser: {
                LOGIN_TAG: "登录",
                LOGIN_PASSWORD_TAG: "密码",
                SWITCH_USER_TAG: "切换账号"
            }
        },
        
        app: {
            common: {
                SAVE_TAG: "保存",
                RESTORE_TAG: "撤销",
                CANCEL_TAG: "取消",
                OK_TAG: "确定",
                BACK_TAG: "返回"
            },
            settings: {
                SETTINGS_TAG: "设置",
                LOG_OUT_TAG: "退出登录",
                APPLICATION_TAG: "应用",
                profile_photo: {
                    LOADING_TAG: "图片加载中...",
                    PROFILE_PHOTO_TAG: "头像",
                    TAKE_PHOTO_TAG: "拍照",
                    CHOOSE_FROM_PHOTOS_TAG: "选择图片"
                },
                name: {
                    NAME_TAG: "姓名",
                    INPUT_NEW_NAME_TAG: "请输入新姓名"
                },
                signature: {
                    SIGNATURE_TAG: "签名",
                    WRITE_SOMETHING: "写点什么吧"
                },
                password: {
                    PASSWORD_TAG: "密码",
                    INPUT_ORIGIN_PASSWORD_TAG: "请输入原密码",
                    INPUT_NEW_PASSWORD_TAG: "请输入新密码",
                    INPUT_NEW_PASSWORD_AGAIN_TAG: "请再输入一次新密码"
                },

                developer_keys: {
                    DEVELOPER_KEYS_TAG: "开发者秘钥"
                },

                widget_code: {
                    WIDGET_CODE_TAG: "聊天组件代码"
                },

                widget_link: {
                    LOOK_NOW_TAG: "现在就看看",            
                    WIDGET_LINK_TAG: "聊天组件链接"
                },

                language: {
                    LANGUAGE_TAG: "语言",
                    CHINESE_TAG: "中文",
                    ENGLISH_TAG: "English"
                },
                
                app: {
                    APP_TAG: "应用"
                },
                
                about: {
                    ABOUT_TAG: "关于",
                    CANT_GET_NEWEST_VERSION_TAG: "无法获取版本信息",
                    IS_NEWEST_VERSION_TAG: "已是最新版本",
                    UPGRADE_TO_VERSION_TAG: "更新至版本 "
                }              
                
            },
            
            messages: {
                MESSAGE_TAG: "消息",
                CONVERSATIONS_TAG: "对话",
                MARK_AS_READ_TAG: "已读",
                DELETE: "删除",
                ALL: "所有",
                UNASSIGNED: "未分配",
                MINE: "我的"
            },
            
            contact: {
                CONTACT_TAG: "通讯录",
                SERVICE_TAG: "服务",
                SEARCH_TAG: "搜索",
                SERVANT: "客服",
                CUSTOMER: "客户"
            },
            
            
            
            detailInfo: {
                DETAIL_INFO_TAG: "详细信息",
                FULLNAME_TAG: "名称",
                LOGIN_NAME_TAG: "登录名",
                PROFILE_PHOTO_TAG: "头像",
                TYPE_TAG: "类型: ",
                MAIL_TAG: "邮箱",
                IDENTITY_TAG: "身份",
                BELONG_TO_ORG_TAG: "所属组织",
                MESSAGE_HISTORY_TAG: "消息历史",
                CHAT_WITH_USER_TAG: "对话",
                DELETE_USER_TAG: "删除联系人",
                INVITE_USER_AS_CONTACT_TAG: "邀请为联系人",

                USER_EMAIL: "邮箱",
                USER_IDENTITY: "身份",
                USER_EDUCATION: "学历",
                USER_CALENDAR: "学年制",
                USER_DEPARTMENT: "院系",
                USER_MAJOR: "专业",
                USER_CLASS: "班级",

                INVITE_CONTACT: "我想要加你为好友."
            },

            leftPanel: {
                MESSAGE_TAG: "消息",
                CONTACTS_TAG: "通讯录",
                SETTINGS_TAG: "设置"
            },

            messageThread: {
                PULL_TO_LOAD_MORE: "更多",
                LOGIN_PASSWORD_TAG: "登录密码",
                OK_TAG: "确定",
                CANCEL_TAG: "取消",
                CHOOSE_CONTACTS_TAG: "选择联系人",
                SEARCH_CONTACTS_TAG: "根据关键词搜索联系人",

                SEND: "发送",
                SEND_TIP: "按Ctrl+Enter换行",
                TEXTAREA_TIP: "写点什么吧...",

                FILE: "文件",
                PICTURE: "图片",
                CAMERA: "拍照",
                LOCATION: "位置",
                SLACK: "Slack",
                EVERNOTE: "印象笔记",

                ASSIGN: "分配",
                TYPE: "类型",
                SERVICE_USER: "客服",
                PORTAL_USER: "客户",
                TOGGLE_FONT_SIZE: "改变字体大小: "
            },

            lockPopover: {
                COPY_TAG: "复制",
                ENCRYPTOIN_TAG: "加密",
                DECRYPTION_TAG: "解密",
                DELETE_TAG: "删除"
            },

            myContacts: {
                SEARCH_HINT_TAG: "搜索"
            },

            messageHistory: {
                PULL_TO_LOAD_MORE: "更多"
            },

            chatModal: {
                CHOOSE: "选择",
                CANCEL: "取消"
            },

            LOCAL: {

                SAVE_TO_PHONE: "保存到手机",

                SAVE: "保存",

                CHECK_UPDATE: "更新至",
                IS_UPDATED: "已是最新版本",
                GET_VERSION_FAIL: "无法获取最新版本",

                PROMPT_LEAVE: "确定离开？"

            },

            COMMON: {
                ERR_TITLE: "错误",
                INFO_TITLE: "提示",
                SET_SUCCESS: "设置成功",
                SET_FAILURE: "设置失败"
            },

            changeiconctrl: {
                SMALL_ICON: "图片大小不得小于160x160像素！"
            },

            changefullnamectrl: {
                FULLNAME_EMPTY: "名称不能为空",
                FULLNAME_TOO_LARGE: "名称最长不超过32个字符"
            },

            changepwdctrl: {
                PROMPT_EMPTY: "原密码和新密码都不能为空",
                PROMPT_PWD_ERROR: "原密码错误",
                PROMPT_VERIFY_ERROR: "两次输入的新密码不一致",
                PROMPT_SAME_ERROR: "新密码不能和原密码相同",
                PROMPT_LENGTH: "密码长度不能超过16"
            },

            conversationsctrl: {
                NO_MESSAGE: "暂无消息，向右滑动查看主菜单。"
            },

            GLOBAL: {
                ERR_TOKEN: "无法获取token",
                ERR_NET: "无法连接服务器",
                ERR_LOGIN: "无法登录",
                ERR_USERPASS: "用户名称密码不匹配",
                ERR_IOSTOKEN: "获取推送消息标识出错",
                ERR_NO_SERVER: "没有选中任何服务器",
                ERR_NO_PASSWORD_EMAIL: "没有填写邮箱或密码",
                ERR_NO_ENOUGH_INFO: "提供的参数不够",

                NOTIFICATION_CHANGE_SUCCESS: "成功变更推送方式",
                NOTIFICATION_CHANGE_FAIL: "变更推送方式失败",
                NOTIFICATION_TYPE: "推送方式",
                
                ONLINE: "在线",
                OFFLINE: "离线",

                
                CANT_GET_MORE_HISTORY_MESSAGES: "无法获取更多历史消息",
                CANT_GET_MORE_CONVERSATIONS: "无法获取更多对话",
                CANT_REFRESH_CONVERSATIONS: "无法刷新对话",
                
                TITLE_FILE:        "文件消息",
                TITLE_TEXT:        "文本消息",
                TITLE_IMAGE:       "图片消息",
                TITLE_LOGOUT:      "退出登录消息",
                TITLE_UNKNOWN:     "未知消息",

                CANT_OPEN_FILE:    "不能打开此文件",
                
                
                TIMESTAMP_LANGUAGE: "zh-cn",
                TIMESTAMP_FORMAT: "MM月DD日 HH:mm",

                
                ALERT_OK: "确定",
                ALERT_CANCEL: "取消",
                CLOSE: "关闭",
                SAVE: "保存",
                SAVE_PHOTO_SUCCESS: "图片已保存到相册",
                SAVE_PHOTO_FAILURE: "图片保存失败",
                DOWNLOAD_FAILURE: "下载失败",

                LOGIN_IN_ANOTHER_DEVICE: "你的账户在其他设备上登录",

                FILE: "文件",
                PICTURE: "图片",
                CAMERA: "拍照",
                LOCATION: "位置",
                MESSAGE_CONTENT: "消息内容",
                
                CANCEL: "取消",
                COPY: "复制",
                FORWARD: "转发",
                DELETE: "删除",
                LOCK: "加锁",
                UNLOCK: "解锁",

                RELOAD: "重新加载",
                SEARCH: "搜索",
                YESTERDAY: "昨天",

                UPDATE_TITLE: "有新版本！",
                UPDATE_CONTENT1: "当前版本为",
                UPDATE_CONTENT2: ", 是否升级到最新版本",
                UPDATE_CONTENT3: " ？",

                UPDATE_FAILED: "更新失败",
                UPDATE_SUCCESS: "更新成功",

                NO_RECENT_MESSAGE: "没有最近消息",
                NO_MORE_HISTORY_MESSAGES: "没有更多的历史消息",
                
                CHECKING_FILE: "检查文件 ...",
                UPLOADING_FILE: "上传文件 ...",
                SENDING: "发送消息 ...",
                CANCELED: "已取消",                
                TYPING: "正在输入 ",
                
                CONVERSATIONS: "对话",
                CONTACTS: " 联系人",
                SELECT_APP: "选择应用",
                PRECEED: "继续",
                QUIT: "退出",
                REMEMBER_MY_CHOICE: "记住我的选择",
                NO_CONVERSATION_SELECTED: "未选中任何对话",
                NO_CONTACT_SELECTED: "未选中任何联系人",
                NO_SETTING_SELECTED: "未选中任何设置项",
                NO_CONVERSATION: "没有对话",
                NO_CONTACT: "没有联系人",
                NO_RESULTS: "没有结果",
                YOU_DONT_HAVE_ANY_APP: "你没有任何应用",
                ON_BEFORE_UNLOAD_WARNING: "关闭窗口会导致退出登录",
                NO_MATCH_RESULTS: "没有符合的结果",

                USER_FULLNAME: "用户全名",
                USER_PASSWORD: "用户密码",
                USER_PASSWORD_REPEAT: "重复用户密码",
                USER_EMAIL: "用户邮箱",
                ADD_SERVICE_USER: "添加座席",

                SUBMIT: "提交",

                REQUIRED_NOT_PROVIDED: "缺参数",
                PASSWORD_REPEAT_NOT_MATCH: "密码不一致",
                PASSWORD_TOO_LONG: "密码太长"

            }
        }
    }

});

ppmessageModule.factory("yvConstants", [function () {
    
    return {

        DEV_MODE: true,
        
        UPDATE_YVOBJECT_INTERVAL: 3600 * 24,
        MESSAGE_MAX_TEXT_LEN:     128,
        PCSOCKET_PORT:            8931,
        PCAPP_PORT:               8927,
        DOWNLOAD_PORT:            8924,
        UPLOAD_PORT:              8928,
        API_PORT:                 8922,
        ADMINWEB_PORT:            8920,
        PORTAL_PORT:              8080,
        OAUTH_PORT:               8930,

        ONLINE_STATUS: {
            ONLINE: "ONLINE",
            OFFLINE: "OFFLINE",
            UNCHANGED: "UNCHANGED"
        },

        USER_STATUS: {
            READY: "READY",
            REST: "REST",
            BUSY: "BUSY",
            NULL: "NULL"
        },
        
        ADDING_TYPE: {
            FILE: "FILE",
            PICTURE: "PICTURE",
            CAMERA: "CAMERA",
            LOCATION: "LOCATION",
            SLACK: "SLACK",
            EVERNOTE: "EVERNOTE"
        },
        
        PC_SOCKET_STATUS: {
            NULL: "NULL",
            CONNECTING: "CONNECTING",
            CONNECTED: "CONNECTED",
            KICKED: "KICKED"
        },

        DIS_ERR: {
            NOERR:  0,
            FORMAT: 1,
            AUTH:   2,
            QUIT:   3
        },

        CHAT_STATUS: {
            NULL:             "NULL",
            ADDING:           "ADDING",
            TEXTING:          "TEXTING",
            CAPTURING:        "CAPTURING",
            CAPTURED:         "CAPTURED",
            RECORDING:        "RECORDING",
            RECORDING_PRE:    "RECORDING_PRE",
            RECORDING_CANCEL: "RECORDING_CANCEL"
        },

        THUMBNAIL: {
            WIDTH: 120,
            HEIGHT: 160
        },

        AVATAR: {
            WIDTH: 140,
            HEIGHT: 140
        },
        
        API_ERR: {
            NO_ERR: 0,
            NO_JSON: 1,
            NO_UUID: 2,
            NO_ACCESS_TOKEN: 3,
            WRONG_ACCESS_TOKEN: 4,
            NO_VALID: 5,
            NO_PARA: 6,
            NO_USER: 7,
            NO_DEVICE: 8,
            NO_ENT: 9,
            MIS_ERR: 10,
            NO_TASK: 11,
            NO_PUSH: 12,
            NO_APP: 13,
            NO_FILE: 14,
            NO_MATERIAL: 15,
            MESSAGE: 16,
            SYS_ERR: 17,
            NO_OBJECT: 18,
            ERR_SIG: 19,
            NO_PERM: 20,
            EX_USER: 22,
            ERROR_VERIFY_CODE: 24
        },

        MESSAGE_TYPE: {
            NOTI: "NOTI",
            SYS: "SYS"
        },

        MESSAGE_SUBTYPE: {
            FILE:   "FILE",
            TEXT:   "TEXT",
            IMAGE:  "IMAGE",
            MENU:   "MENU",
            EVENT:  "EVENT",
            LOGOUT: "LOGOUT"
        },

        YVOBJECT: {
            DEVICE_USER: "DU",
            ORG_GROUP:   "OG",
            APP_GROUP:   "AG",
            DIS_GROUP:   "DG",
            ADMIN_USER:  "AU",
            CONVERSATION: "CV"
        },

        PLAY_STATUS: {
            PLAY_NULL:    "PLAY_NULL",
            PLAY_PLAYING: "PLAY_PLAYING"
        },

        SEND_STATUS: {
            SEND_PENDING:   "SEND_PENDING",
            SEND_CHECKING:  "SEND_CHECKING",
            SEND_UPLOADING: "SEND_UPLOADING",
            SEND_SENDING:   "SEND_SENDING",
            SEND_CANCELED:   "SEND_CANCELED",            
            SEND_SUCCESS:   "SEND_SUCCESS",
            SEND_ERROR:     "SEND_ERROR"
        },

        RECV_STATUS: {
            RECV_PLAY:   "RECV_PLAY",
            RECV_OPEN:   "RECV_OPEN",
            RECV_NEW:    "RECV_NEW",
            RECV_UNACK:  "RECV_UNACK"
        },

        MESSAGE_DIR: {
            DIR_IN:  "DIR_IN",
            DIR_OUT: "DIR_OUT"
        },

        INVITE_STATUS: {
            INVITE_PENDING: "INVITE_PENDING",
            INVITE_READ: "INVITE_READ",
            INVITE_ACCEPTED: "INVITE_ACCEPTED"
        },

        MENU_TYPE: {
            FUNC: 'FUNC',
            WEB: 'WEB',
            MSG: 'MSG'
        },

        APP_MENU_ARRAY: ["messages", "contacts", "settings"],

        CONVERSATION_TYPE: {
            S2S: "S2S",
            S2P: "S2P",
            P2S: "P2S"
        },

        DEFAULT_BUNDLE_NAME: "PPMessage",

        OS: {
            MAC: "MAC",
            WIN32: "WIN32",
            WIN64: "WIN64",
            LINUX: "LINUX",
            DARWIN: "DARWIN"
        },

        PLATFORM: {
            IOS: "IOS", // IOS
            WIP: "WIP", // WINDOWS PHONE
            ANDROID: "AND", // ANDROID
            
            IOS_BROWSER: "IOB", // IOS BROWSER
            WIP_BROWSER: "WPB", // WINDOWS PHONE BROWSER
            ANDROID_BROWSER: "ANB", // ANDROID BROWSER
            
            MAC: "MAC", // MAC PC
            LINUX: "LIN", // LINUX PC
            WIN: "WIN", // WINDOWS PC
            WIN32: "W32", // WINDOWS PC 32 BIT
            WIN64: "W64", // WINDOWS PC 64 BIT

            MAC_BROWSER: "MAB", // MAC BROWSER
            LINUX_BROWSER: "LIB", // LINUX BROWSER
            WIN_BROWSER: "WIB", // WINDOWS BROWSER
        },

        NOTIFICATION_TYPE: {
            GCM: "GCM",
            MQTT: "MQTT"
        },
        
    };
    
}]);

$yvUtilService.$inject = ["$base64"];
function $yvUtilService($base64) {
    return {
        uuid: function() {
            var d = new Date().getTime();
            var id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = (d + Math.random()*16)%16 | 0;
                d = Math.floor(d/16);
                return (c=='x' ? r : (r&0x7|0x8)).toString(16);
            });
            return id;
        },

        is_valid_email: function (email) {
            var re = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
            return re.test(email);
        },

        base64_decode: function(input) {
            return $base64.decode(input);
        },

        base64_encode: function(input) {
            return $base64.encode(input);
        },
     
        // check if a string contain unregular words
        regexp_check: function(str) {
            var pattern = RegExp("[\\u4E00-\\u9FFF\\dA-z@\-\_\\s*]+","i");
            if( !str || !str.match(pattern)) {
                return false;
            };
            var reg_length = str.match(pattern).toString().length;
            if (reg_length == str.length)
                return true;
            else
                return false;
        },        
    };
}

ppmessageModule.factory("yvUtil", $yvUtilService);

ppmessageModule.factory("yvLog", [

function () {
    var log = {};
    var methods = ["log", "warn", "error", "green", "yellow", "red"];

    function colorfulLog(style, args) {
        args = ["%c%s", style].concat(args);
        console.log.apply(console, args);              
    }
    
    if (ppmessage.developer_mode) {
        log = {
            log: function () {
                var args = Array.prototype.slice.call(arguments);
                console.log.apply(console, args);              
            },
            warn: function () {
                var args = Array.prototype.slice.call(arguments);
                console.warn.apply(console, args);              
            },
            error: function () {
                var args = Array.prototype.slice.call(arguments);
                console.error.apply(console, args);                
            },
            green: function () {
                var args = Array.prototype.slice.call(arguments);
                colorfulLog("color: green", args);
            },
            yellow: function () {
                var args = Array.prototype.slice.call(arguments);
                colorfulLog("background-color: yellow", args);
            },
            red: function () {
                var args = Array.prototype.slice.call(arguments);
                colorfulLog("color: red", args);
            }
        };
    } else {
        angular.forEach(methods, function (method) {
            log[method] = angular.noop;
        });
    }
    
    return log;
}]);

ppmessageModule.factory("yvSSL", [
    "yvConstants",
function (yvConstants) {
    return {
        ws_protocol: function (host) {
            var _ws = "ws://";
            if (location.protocol == "https:") {
                _ws = "wss://";
            }
            return _ws
        }
    };
}]);

ppmessageModule.factory("yvFile", [
    "yvLog",
    "yvSys",
function (yvLog, yvSys) {

    var _fs = null;

    function errorHandler(e) {
        var file_error = window.FileError,
            msg = '';

        switch (e.code) {
        case file_error.QUOTA_EXCEEDED_ERR:
            msg = 'QUOTA_EXCEEDED_ERR';
            break;
        case file_error.NOT_FOUND_ERR:
            msg = 'NOT_FOUND_ERR';
            break;
        case file_error.SECURITY_ERR:
            msg = 'SECURITY_ERR';
            break;
        case file_error.INVALID_MODIFICATION_ERR:
            msg = 'INVALID_MODIFICATION_ERR';
            break;
        case file_error.INVALID_STATE_ERR:
            msg = 'INVALID_STATE_ERR';
            break;
        default:
            msg = 'Unknown Error';
            break;
        }
        yvLog.error(msg);
    }

    function _randomFileName() {
        return yvSys.get_uuid();
    }

    function _has_file(file, yes, no) {
        var url = _fs.toURL() + file;
        window.resolveLocalFileSystemURL(url, function (_file) {
            yes && yes(_file);
        }, function (error) {
            no && no(error);
        });
    }

    function _remove_file(file, cb) {
        _has_file(file, function (entry) {
            entry.remove(function () {
                cb && cb(file);
            }, function () {
                yvLog.log("===========remove file error", file);
            });
        }, function () {
            cb && cb(file);
        });
    }

    function _getFileExt(_file_name) {
        var list = _file_name.split(".");
        var _ext = list[list.length - 1];
        return _ext;
    }
    
    function _readRandomFile(file_path, readAsText, callback) {
        window.resolveLocalFileSystemURL(file_path, function (fileEntry) {
            fileEntry.file(function (file) {
                var reader = new FileReader();
                reader.onerror = function (e) {
                    yvLog.log(e);
                };
                reader.onprogress = function (e) {
                    yvLog.log();
                };
                reader.onabort = function (e) {
                    yvLog.log(e);
                };
                reader.onloadend = function (e) {
                    callback(reader.result);
                };
                
                if (readAsText == true) {
                    reader.readAsText(file);
                } else {
                    reader.readAsDataURL(file);
                }
            }, function (e) {
                callback && callback("");
                errorHandler
            });
        });
    }

    function _createRandomFileWithoutData(_s, _e) {
        var _file_name = _randomFileName();

        _fs.getFile(_file_name, {create: true}, function (fileEntry) {
            if (_s) {
                _s(_file_name, fileEntry);
            }
        }, function (e) {
            if (_e) {
                _e(e);
            } else {
                errorHandler(e);
            }
        });

        return _file_name;
    }

    function _create_nodata(_file_name, _s, _e) {
        _fs.getFile(_file_name, {create: true}, function (fileEntry) {
            _s && _s(fileEntry);
        }, function (e) {
            errorHandler(e);
        });
        return _file_name;
    }

    function _create_data(_data, _file_name, _encoded, _cb) {
        var _content_data = _data;
        //exclusive:true, if file existed then error
        _fs.getFile(_file_name, {create: true}, function (fileEntry) {
            fileEntry.createWriter(function (writer) {
                if (_encoded) {
                    _content_data = Base64Binary.decodeArrayBuffer(_data);
                }
                writer.onwrite = function (e) {
                    if (_cb) { _cb(_file_name); }
                };
                writer.write(_content_data);
            }, function (e) {
                if (_cb) { _cb(null); }
                errorHandler(e);
            });
        }, function (e) {
            if (_cb) { _cb(null); }
            errorHandler(e);
        });
        return _file_name;
    }

    function _createRandomFile(_data, _encoded, _cb) {
        var _file_name = _randomFileName();
        _create_data(_data, _file_name, _encoded, _cb);
        return _file_name;
    }

    return {
        init: function (cb) {
            window.requestFileSystem(LocalFileSystem.PERSISTENT, 16 * 1024 * 1024, function (fs) {
                if (yvSys.in_ios_app()) {
                    _fs = fs.root;
                    if (cb) { cb(); }
                    yvLog.log("iOS root dir : ", _fs.toURL());
                } else if (yvSys.in_android_app()) {
                    fs.root.getDirectory("YvDoc", {create: true}, function (dirEntry) {
                        _fs = dirEntry;
                        if (cb) { cb(); }
                        yvLog.log("Android root dir: ", _fs.toURL());
                    }, errorHandler);
                }
            }, errorHandler);
        },

        copy_random: function (_url, _ext, _cb) {
            var _file_name = _randomFileName() + "." + _ext;
            window.resolveLocalFileSystemURL(_url, function (fileEntry) {
                fileEntry.copyTo(_fs, _file_name, function (newEntry) {
                    if (_cb) { _cb(_file_name, newEntry); }
                }, errorHandler);
            }, errorHandler);

            return _file_name;
        },

        copy: function (origin, dist, cb) {
            window.resolveLocalFileSystemURL(origin, function (originEntry) {
                originEntry.copyTo(_fs, dist, function (distEntry) {
                    cb && cb(distEntry);
                }, errorHandler);
            }, errorHandler);
        },
        
        read_as_dataurl : function (_name, _cb) {
            return _readRandomFile(_name, false, _cb);
        },

        read_as_text: function (_file, _cb) {
            return _readRandomFile(_file, true, _cb);
        },
        
        create_random: function (_data, _encoded, _cb) {
            return _createRandomFile(_data, _encoded, _cb);
        },

        create_random_nodata: function (_s, _e) {
            return _createRandomFileWithoutData(_s, _e);
        },

        create_nodata: function (_name, _s, _e) {
            return _create_nodata(_name, _s, _e);
        },

        create_data: function (_data, _name, _encoded, _cb) {
            return _create_data(_data, _name, _encoded, _cb);
        },

        get_root_dir: function () {
            if (_fs) {
                return _fs.toURL();
            }
            return null;
        },

        get_random_file_name: function () {
            return _randomFileName();
        },

        has_file: function (file, yes, no) {
            return _has_file(file, yes, no);
        },

        remove_file: function (file, cb) {
            _remove_file(file, cb);
        }

    };
}]);

ppmessageModule.factory("yvAlert", [
    "$timeout",
    "$ionicPopup",
    "blockUI",
    "yvConstants",
    "yvSys",
    "yvLocal",
function ($timeout, $ionicPopup, blockUI, yvConstants, yvSys, yvLocal) {

    function _alert(_title, _content, _cb) {
        var _popup = $ionicPopup.alert({
            title: _title,
            template: "<p style='font-family: Helvetica; text-align: center;'>" + _content + "</p>",
            okText: yvLocal.translate("app.GLOBAL.ALERT_OK")
        });
        _popup.then(function (res) {
            if (res && _cb) { _cb(); }
        });
        $timeout(function () {
            _popup.close();
        }, 1000);
    }

    function _confirm(_title, _content, _yes, _no) {
        var _popup = $ionicPopup.confirm({
            title: _title,
            template: "<p style='font-family: Helvetica;'>" + _content + "</p>",
            cancelText: yvLocal.translate("app.GLOBAL.ALERT_CANCEL"),
            okText: yvLocal.translate("app.GLOBAL.ALERT_OK")
        });
        _popup.then(function (res) {
            if (res && _yes) {
                _yes();
            } else if (_no) {
                _no();
            }
        });
    }

    function _prompt(_title, _default_input, _then) {
        var _popup = $ionicPopup.prompt({
            title: _title,
            inputPlaceholder: _default_input,
            cancelText: yvLocal.translate("app.GLOBAL.ALERT_CANCEL"),
            okText: yvLocal.translate("app.GLOBAL.ALERT_OK")
        });

        _popup.then(function (res) {
            if (res === undefined) {
                console.log("canceld.");
                return;
            }
            if (_then) {
                _then(res);
            }
        });
    }

    function _show(_title, _content, _scope, _yes, _no) {
        // _content should be compatible with ng-model, example: "data.name"
        var _popup = $ionicPopup.show({
            title: _title,
            template: "<input type='text' ng-model=" + _content + ">",
            scope: _scope,
            buttons: [
                {
                    text: yvLocal.translate("app.GLOBAL.ALERT_CANCEL"),
                    onTap: function (e) {
                        if (_no) { _no(e); }
                        return "cancel"; // return a value to resolve promise.
                    }
                },
                {
                    text: yvLocal.translate("app.GLOBAL.ALERT_OK"),
                    type: "button-positive",
                    onTap: function (e) {
                        if (_yes) { _yes(e); }
                        return "ok";
                    }
                }
            ]
        });

        _popup.then(function (res) {
            console.log("tapped", res); // res could be 'cancel' or 'ok'
        });
    }

    function _toast(msg) {
        window.plugins.toast.showShortCenter(msg);
    }

    function _success() {
        var content = yvLocal.translate("app.COMMON.SET_SUCCESS");
        blockUI.start();
        blockUI.message(content);
        $timeout(function () {
            blockUI.stop();
        }, 1000);
    }

    function _fail() {
        var content = yvLocal.translate("app.COMMON.SET_FAILURE");
        blockUI.start();
        blockUI.message(content);
        $timeout(function () {
            blockUI.stop();
        }, 1000);
    }

    // by default, content will be translated to current locale
    function _tip(content, dontTranslate) {
        if (!dontTranslate) {
            content = yvLocal.translate(content);
        }
        blockUI.start();
        blockUI.message(content);
        $timeout(function () {
            blockUI.stop();
        }, 1000);
    }

    return {
        alert: function (title, content, cb) {
            _alert(title, content, cb);
        },

        confirm: function (title, content, yes, no) {
            _confirm(title, content, yes, no);
        },

        prompt: function (title, default_input, then) {
            _prompt(title, default_input, then);
        },

        show: function (title, content, scope, yes, no) {
            _show(title, content, scope, yes, no);
        },

        toast: function (msg) {
            _toast(msg);
        },

        success: function () {
            _success();
        },

        fail: function () {
            _fail();
        },

        tip: function (content, dontTranslate) {
            _tip(content, dontTranslate);
        }
    };

}]);

ppmessageModule.factory('yvAPI', [
    "$rootScope",
    "$timeout",
    "$http",
    "yvLog",
    "yvSys",
    "yvUser",
    "yvFile",
    "yvConstants",
function ($rootScope, $timeout, $http, yvLog, yvSys, yvUser, yvFile, yvConstants) {
    
    var API_REQUEST_TIMEOUT = 150000;   // 15s
    var _current_server = {
        id: -1,
        name: "",
        host: "",
        protocol: "",
        api_url: "",
        auth_url: "",
        pcapp_url: "",
        download_url: "",
        upload_url: ""
    };

    function _request_signature(request_uuid) {
        var _s = yvUser.get("app").app_secret + request_uuid;
        return hex_sha1(_s).toLowerCase();
    }

    function _api_post(_url, _data, _config, _success, _error, _api_error) {

        function _default_success(response) {
            var code = response.error_code;
            
            yvLog.log("POST SUCCESS URL: %s, DATA: %o, RESPONSE: %o.", _url, _data, response);
            if (code === 0) {
                if (_success) { _success(response); }
                return;
            }

            if (_api_error) {
                _api_error(response);
            }

            if (code === yvConstants.API_ERR.NO_ACCESS_TOKEN || code === yvConstants.API_ERR.WRONG_ACCESS_TOKEN) {

                // IGNORE ERROR WHEN LOGOUT
                if (_url.indexOf("LOGOUT") !== -1) {
                    return;
                }

                $timeout(function () {
                    $rootScope.$broadcast("event:logout");
                });
            }
        }

        function _default_error(response) {
            yvLog.error("POST ERROR url: %s, data: %o, response:%o.", _url, _data, response);
            if (_error) {
                _error(response);
            }
        }

        var _user_uuid = yvUser.get("uuid"),
            _app_uuid = yvUser.get("app").uuid,
            _device_uuid = yvUser.get("device_uuid"),
            _api_url = _current_server.api_url + _url,
            _api_data = _data || {},
            _api_config = {};

        _api_data.app_uuid = _app_uuid;
        _api_data.user_uuid = _user_uuid;
        _api_data.device_uuid = _device_uuid;

        _api_config.url = _api_url;
        _api_config.method = "POST";
        _api_config.data = _api_data;
        _api_config.headers = {
            "Content-Type": "application/json",
            "Authorization": "OAuth " + yvUser.get("access_token"),
        };
        
        // Add custom config 
        angular.forEach(_config, function (value, key) {
            _api_config[key] = value;
        });
        
        yvLog.log("API POST url: %s, data: %o.", _api_config.url, _api_config.data);
        
        return $http(_api_config)
            .then(function (response) {
                _default_success(response.data);
            }, function(response) {
                _default_error(response);
            });
    }

    function _api_token(_session, _success, _error, _api_error) {
        
        function _default_success(response, status, headers, config) {
            yvLog.log("_api_token SUCCESS response: %o", response);
            
            if (response.error_code != 0) {
                yvLog.error("_api_token: %o", response);
                if (_api_error) _api_error();
                return;
            }
            
            yvUser.set("access_token", response.access_token);
            if (_success) { _success(response); }
            return;
        }

        function _default_error(response, status, headers, config) {
            yvLog.error("_api_token ERROR response:%o.", response);
            if (_error) {
                _error(response, status, headers, config);
            }
        }

        var _auth_url = _current_server.auth_url + "/token";
        var _auth_data = "grant_type=password&user_email=" + _session.user_email
            + "&user_password=" + _session.user_password
            + "&client_id=" + window.ppmessage.api_key;
        var _auth_config = {};
        
        _auth_config.url = _auth_url;
        _auth_config.method = "POST";
        _auth_config.data = _auth_data;
        _auth_config.headers = {
            "Content-Type": "application/x-www-form-urlencoded",
        };
        
        yvLog.log("AUTH POST url: %s, data: %o.", _auth_config.url, _auth_config.data);
        
        return $http(_auth_config).then(function(response) {
            _default_success(response.data);
        }, function (response) {
            _default_error(response);
        });
    }
    
    function _api_login(_session, _success, _error, _api_error) {
        var _url = "/PPKEFU_LOGIN";
        var _config = {timeout: API_REQUEST_TIMEOUT};
        var _data = {
            osmodel: _session.device_model,
            terminal: _session.device_uuid,
            ostype: _session.device_platform,
            osversion: _session.device_version,
            device_fullname: _session.device_fullname
        };
        
        if (_session.user_email) {
            _data.user_email = _session.user_email;
            _data.user_password = _session.user_password;
            return _api_post(_url, _data, _config, _success, _error, _api_error);
        }

        yvLog.error("yvAPI._api_login: neither user_email or user_uuid is valid, will return");
        _error && _error();
        return
    }

    function _update_device(_token, _success, _error, _api_error) {
        var _url = "/SET_DEVICE_INFO",
            _device = yvSys.get_device_info(),
            _info = {
                'fullname': yvSys.get_terminal_fullname(),
                'osversion': _device.version,
                'ostype': _device.platform,
                'iosmodel': _device.model
            };
        _api_post(_url, _info, null, _success, _error, _api_error);
    }

    
    function _get_file_name(url) {
        var list = url.split("/");
        var length = list.length;
        if (!length) {
            return null;
        }
        return list[length - 1];
    }

    
    function _upload_file(_url, _file_url, _mime, _cb, _onprogress) {
        var _uri = encodeURI(_url);
        var ft = new FileTransfer();
        var options = new FileUploadOptions();

        // could begin with "file://" or "cdvfile://"
        if (_file_url.indexOf("file://") !== 0 && _file_url.indexOf("cdvfile://") !== 0) {
            _file_url = yvFile.get_root_dir() + _file_url;
        }
        
        options.fileKey = "file";
        options.mimeType = _mime;
        options.fileName = _get_file_name(_file_url);
        options.params = { user_uuid: yvUser.get("uuid") };

        // If we don't set chunkedMode to false, in android app, upload file to 'https://ppmessage.cn/upload' will fail,
        // but upload file to 'http://localhost:8080/upload' still works. It must have something to do with https/http protocol
        // and nginx.conf. iOS app has not such problem though.
        // To fix this problem, we have to set chunkedMode to false.
        if (yvSys.in_android_app() && _current_server.protocol == "https://") {
            options.chunkedMode = false;
        }

        if (_onprogress) {
            ft.onprogress = _onprogress;
        }

        ft.upload(_file_url, _uri, function (_r) {
            yvLog.log("FileTransfer ok: %o", _r);
            if (_cb) { _cb(_r.response); }
        }, function (_err) {
            yvLog.error("FileTransfer _err: %o.", _err);
            if (_cb) { _cb(null); }
        }, options, true);
    }


    function _download_file(url, targetFile, success, error) {
        targetFile = encodeURI(targetFile);
        yvFile.has_file(targetFile, function (file) {
            success && success(file);
            yvLog.log("no need to download this file", file.name);
        }, function () {
            var ft = new FileTransfer();
            var source = encodeURI(url);
            var target = yvFile.get_root_dir() + targetFile;
            
            ft.download(source, target, function (file) {
                yvLog.log("download file successfully", file.name);
                // Wrap callback within $timeout to tell angular to update element.
                $timeout(function () {
                    success && success(file);
                });
            }, function (err) {
                error && error(err);
            }, true, null);
        });
    }

    function _get_default_header() {
        var header = {
            "X-Device-UUID": yvUser.get("device_uuid"),
            "X-User-UUID": yvUser.get("uuid"),
            "X-Session-UUID": yvUser.get("session_uuid")
        };

        return header;
    }

    function _download_html(_uuid, file_name) {
        var _url = _current_server.pcapp_url + "/material/" + _uuid + "?file_name=" + file_name,
            _header = _get_default_header(),
            _config = {method: "GET", url: _url, headers: _header};

        return $http(_config);
    }

    function _download_txt(_uuid) {
        var file_name = _uuid + ".txt";
        return _download_html(_uuid, file_name);
    }

    return {
        set_server: function (server) {
            if (!server || server.id === -1) {
                _current_server = {id: -1};
                return;
            }

            var pre = server.protocol + server.host;
            if (server.port) {
                pre = pre + ":" + server.port;
            }
            _current_server.id = server.id;
            _current_server.name = server.name;
            _current_server.host = server.host;
            _current_server.port = server.port;
            _current_server.protocol = server.protocol;

            _current_server.api_url = pre + "/api";
            _current_server.auth_url = pre + "/ppauth";
            _current_server.pcapp_url = pre + "/ppkefu";
            _current_server.upload_url = pre + "/ppupload/ppupload/";
            _current_server.download_url = pre + "/ppdownload/ppdownload/";
        },

        get_server: function () {
            return _current_server;
        },

        token: function (_session, _success, _error, _api_error) {
            _api_token(_session, _success, _error, _api_error);
        },
        
        login: function (_session, _success, _error, _api_error) {
            _api_login(_session, _success, _error, _api_error);
        },

        logout: function (_success, _error, _api_error) {
            var _service_url = "/PPKEFU_LOGOUT";
            return _api_post(_service_url, null, null, _success, _error, _api_error);
        },
        
        get_yvobject: function (_id, _type, _ts, _success, _error, _api_error) {
            var _url = "/GET_YVOBJECT_DETAIL";
            var _data = {uuid: _id, type: _type, timestamp: _ts};
            _api_post(_url, _data, null, _success, _error, _api_error);
        },

        get_user_info: function (_user_uuid, _success, _error, _api_error) {
            var _url = "/PP_GET_USER_INFO";
            var _data = {user_uuid: _user_uuid};
            _api_post(_url, _data, null, _success, _error, _api_error);
        },

        update_device: function (_token, _success, _error, _api_error) {
            _update_device(_token, _success, _error, _api_error);
        },

        update_device_info: function (_data, _success, _error, _api_error) {
            var _url = "/SET_DEVICE_INFO";
            _api_post(_url, _data, null, _success, _error, _api_error);
        },

        send_message: function (_m, _success, _error, _api_error) {
            var _url = "/PP_SEND_MESSAGE";
            _api_post(_url, _m, null, _success, _error, _api_error);
        },

        forward_message: function (_m, _success, _error, _api_error) {
            var _url = "/FORWARD_MESSAGE";
            _api_post(_url, _m, null, _success, _error, _api_error);
        },

        ack_message: function (_data, _success, _error, _api_error) {
            var _url = "/ACK_MESSAGE";
            _api_post(_url, _data, null, _success, _error, _api_error);
        },

        update_user: function (_data, _success, _error, _api_error) {
            var _url = "/PP_UPDATE_USER";
            if (!_data.user_uuid) {
                _data.user_uuid = yvUser.get("uuid");
            }
            _api_post(_url, _data, null, _success, _error, _api_error);
        },

        get_page_history_message: function (_args, _success, _error, _api_error) {
            var _url = "/PP_PAGE_HISTORY_MESSAGE";
            _api_post(_url, _args, null, _success, _error, _api_error);
        },

        get_app_version: function (_args, _success, _error, _api_error) {
            var _url = "/GET_APP_VERSION";
            _api_post(_url, _args, null, _success, _error, _api_error);
        },
        download_html: function (_uuid, file_name) {
            return _download_html(_uuid, file_name);
        },

        download_file: function (_id_or_url, _save_name, _success, _error) {
            var _url = null, _target = null;
            
            if (_id_or_url.startsWith("http")) {
                _url = _id_or_url;
                _target = _save_name || hex_sha1(_id_or_url);
            } else {
                _url = _current_server.download_url + _id_or_url;
                _target = _save_name || _id_or_url;
            }
            
            _download_file(_url, _target, _success, _error);
        },

        upload_file: function (_file_url, _mime, _cb, _onprogress) {
            var _url = _current_server.upload_url;
            return _upload_file(_url, _file_url, _mime, _cb, _onprogress);
        },

        is_file_existed: function (_file_sha1, _success, _error, _api_error) {
            var _url = "/FILE_IS_EXISTED";
            _api_post(_url, {digest: _file_sha1}, null, _success, _error, _api_error);
        },

        get_icon_url: function (_icon) {
            var _url = _current_server.pcapp_url + "/icon/" + _icon;
            return _url;
        },

        get_image_url: function (_file, _ext) {
            var _url = _current_server.pcapp_url + "/material/" + _file + "?file_name=" + _file + "." + _ext;
            return _url;
        },

        download_web_material: function (_material, _name) {
            var _href = _current_server.pcapp_url + "/material/" + _material + "?file_name=" + _name;
            yvSys.click_download(_href, _name);
        },

        get_service_user_list: function (_success, _error, _api_error) {
            var _url = "/PP_GET_SERVICE_USER_LIST";
            return _api_post(_url, null, null, _success, _error, _api_error);
        },

        get_service_user_conversation_list: function (_success, _error, _api_error) {
            var _url = "/PP_GET_USER_CONVERSATION_LIST";
            var _args = {user_uuid: yvUser.get("uuid"), app_uuid: yvUser.get("app").uuid};
            return _api_post(_url, _args, null, _success, _error, _api_error);
        },


        close_conversation: function (_conv_uuid, _success, _error, _api_error) {
            var _url = "/PP_CLOSE_CONVERSATION";
            var _args = {user_uuid: yvUser.get("uuid"), conversation_uuid: _conv_uuid};
            return _api_post(_url, _args, null, _success, _error, _api_error);
        },

        get_conversation: function (_conv_uuid, _success, _error, _api_error) {
            var _url = "/PP_GET_CONVERSATION_INFO";
            var _args = {
                app_uuid: yvUser.get("app").uuid,
                conversation_uuid: _conv_uuid,
                user_uuid: yvUser.get("uuid")
            };
            return _api_post(_url, _args, null, _success, _error, _api_error);
        },

        assign_conversation: function (_conv_uuid, _assigned_uuid, _success, _error, _api_error) {
            var _url = "/PP_UPDATE_CONVERSATION";
            var _args = {conversation_uuid: _conv_uuid, assigned_uuid: _assigned_uuid};
            return _api_post(_url, _args, null, _success, _error, _api_error);
        },

        update_conversation_member: function (_args, _success, _error, _api_error) {
            var _url = "/PP_UPDATE_CONVERSATION_MEMBER";
            return _api_post(_url, _args, null, _success, _error, _api_error);
        },
        
        get_conversation_user_list: function (conversation_uuid, _success, _error, _api_error) {
            var _url = "/PP_GET_CONVERSATION_USER_LIST";
            var _args = { "conversation_uuid": conversation_uuid }
            
            return _api_post(_url, _args, null, _success, _error, _api_error);
        },
        
        get_selected_group_user: function (_args, _success, _error, _api_error) {
            var _url = "/PP_SELECT_USERS_BY_GROUP_ALGORITHM";
            
            return _api_post(_url, _args, null, _success, _error, _api_error);
        },

        get_conversation_page: function (_args, _success, _error, _api_error) {
            var _url = "/PP_PAGE_USER_CONVERSATION";
            _args.user_uuid = yvUser.get("uuid");
            return _api_post(_url, _args, null, _success, _error, _api_error);
        },

        test_api: function (_success, _error, _api_error) {
            var _url = "/PP_GET_USER_INFO";
            var _data = {user_uuid: yvUser.get("uuid")};
            var _config = {"timeout": 10000};
            _api_post(_url, _data, _config, _success, _error, _api_error);            
        },

        validate_online_device: function (_success, _error, _api_error) {
            var _url = "/PP_VALIDATE_ONLINE_DEVICE";
            var _data = {};
            _api_post(_url, _data, null, _success, _error, _api_error);
        },

        set_user_status: function (_user_status, _success, _error, _api_error) {
            var _url = "/PPKEFU_SET_SERVICE_USER_STATUS";
            var _data = { "user_status": _user_status };
            _api_post(_url, _data, null, _success, _error, _api_error);
        },

        request: function(_url, _params, _success, _error, _api_error) {
            return _api_post(_url, _params, null, _success, _error, _api_error);
        }

    };
}]);

ppmessageModule.factory("yvType", [
    "yvConstants",
function (yvConstants) {

    function _get_subtype(message) {
        // message query from db
        if (message.subtype) {
            return message.subtype;
        }
        // incoming message message subtype
        if (message.ms) {
            return message.ms;
        }

        return null;
    }

    return {
        is_logout: function (message) {
            var subtype = _get_subtype(message);
            if (subtype === yvConstants.MESSAGE_SUBTYPE.LOGOUT) {
                return true;
            }
            return false;
        },

        is_file: function (message) {
            var subtype = _get_subtype(message);
            if (subtype === yvConstants.MESSAGE_SUBTYPE.DOCUMENT) {
                return true;
            }
            if (subtype === yvConstants.MESSAGE_SUBTYPE.FILE) {
                return true;
            }
            return false;
        },

        is_text: function (message) {
            var subtype = _get_subtype(message);
            if (subtype === yvConstants.MESSAGE_SUBTYPE.TEXT) {
                return true;
            }
            return false;
        },

        is_image: function (message) {
            var subtype = _get_subtype(message);
            if (subtype === yvConstants.MESSAGE_SUBTYPE.IMAGE) {
                return true;
            }
            return false;
        },

        is_left: function (message) {
            if (message.direction === yvConstants.MESSAGE_DIR.DIR_IN) {
                return true;
            }
            return false;
        },

        is_right: function (message) {
            if (message.direction === yvConstants.MESSAGE_DIR.DIR_OUT) {
                return true;
            }
            return false;
        }
    };
}]);

ppmessageModule.factory("yvDB", [
    "$rootScope",
    "$timeout",
    "yvAPI",
    "yvSys",
    "yvNav",
    "yvUser",
    "yvConstants",
function ($rootScope, $timeout, yvAPI, yvSys, yvNav, yvUser, yvConstants) {

    "use strict";

    var _userdb = null, _yvdb = null, _current_server = {id: -1};

    function _open_db(name) {
        return window.openDatabase(name, "1.0", name, 12 * 1024 * 1024);
    }


    function _reset() {
        var _yvdb = _open_db("yvdb");
        _yvdb.transaction(function (tx) {
            var _sql = "UPDATE yvdb_login_users SET is_online = 0, logout_time = ? WHERE id = ?";
            var _values = [Math.round(Date.now() / 1000), yvUser.get("id")];
            //FIXME: yvUser.get_master_db_id() return null
            tx.executeSql(_sql, _values, null, function (tx, err) {
                console.log(err);
            });
        });
        $rootScope.$broadcast("event:reset-base");
        yvNav.exit_app(true);
    }


    function _exec(_db, _sql, _value, _success, _error) {
        if (!_db) {
            _reset();
            return;
        }

        function __default_success(tx, res) {
            return;
        }

        function __default_error(tx, res) {
            console.error(res);
            console.error("error SQL statement", _sql);
            console.error("error SQL value", _value);
        }

        _success = _success || __default_success;
        _error = _error || __default_error;

        _db.transaction(function (tx) {
            tx.executeSql(_sql, _value, _success, _error);
        }, function (error) {
            console.error(error);
        });
    }


    function _open_yvdb() {
        try {
            _yvdb = _open_db("yvdb");
        } catch (error) {
            console.error("encount error when init yvdb", error);
        }

        return _yvdb;
    }


    function _set_server(server) {
        _current_server.id = server.id;
        _current_server.name = server.name;
        _current_server.host = server.host;
        _current_server.port = server.port;
        _current_server.protocol = server.protocol;
        yvAPI.set_server(_current_server);
    }


    function _init_yvdb_has_user(user_uuid, callback) {
        function _init_callback() {
            callback && callback(yvUser.get());
        }
        
        _init_userdb(user_uuid, function () {
            var _sql = "SELECT * FROM userdb_objects WHERE uuid = ?";
            
            _exec(_userdb, _sql, [user_uuid], function (tx, res) {
                if (res.rows.length === 0) {
                    return _init_callback();
                }
                yvUser.mset(res.rows.item(0));
                _init_callback();
            }, function (tx, err) {
                _init_callback();
            });
        });
    }


    function _pick_user(cb) {
        var _sql0 = "SELECT * FROM yvdb_servers WHERE is_selected = 1 LIMIT 1";
        var _sql1 = "SELECT * FROM yvdb_login_users WHERE server_id = ? ORDER BY login_time DESC LIMIT 1";

        _exec(_yvdb, _sql0, [], function (tx, res) {
            if (res.rows.length === 0) {
                cb && cb(null);
                return;
            }

            var _o = res.rows.item(0);
            _set_server(_o);
            
            _exec(_yvdb, _sql1, [_o.id], function (tx, res) {
                if (res.rows.length === 0) {
                    cb && cb(null);
                    return;
                }
                var item = res.rows.item(0);
                yvUser.update_user_from_db(item);
                _init_yvdb_has_user(item.user_uuid, cb);
            }, function (tx, err) {
                cb && cb(null);
            });
        });
    }


    function _create_servers(callback) {
        // uncomment this to force drop tables
        // _exec(_yvdb, "drop table if exists yvdb_servers", [], null, null);
        var _sql0 = "CREATE TABLE IF NOT EXISTS yvdb_servers (id integer primary key, name text, " +
                " host text UNIQUE, port text, protocol text, is_selected integer)";
        var _sql1 = "SELECT * FROM yvdb_servers WHERE host=?";
        var _sql2 = "UPDATE yvdb_servers SET is_selected = 0";
        var _sql3 = "INSERT INTO yvdb_servers (name, host, port, protocol, is_selected) VALUES (?, ?, ?, ?, ?)";
        var _server = [ppmessage.server.name, ppmessage.server.host, ppmessage.server.port, ppmessage.server.protocol, 1];

        _exec(_yvdb, _sql0, [], null, null);
        _exec(_yvdb, _sql1, [ppmessage.server.host], function (tx, res) {
            if (res.rows.length === 0) {
                _exec(_yvdb, _sql2, [], function (tx, res) {
                    _exec(_yvdb, _sql3, _server, function (tx, res) {
                        callback && callback();
                    }, null);
                }, null);
                return;
            }
            callback && callback();
        }, null);
    }


    function _create_login_user () {
        // uncomment this to force drop tables
        // _exec(_yvdb, "drop table if exists yvdb_login_users", [], null, null);
        var _sql = "CREATE TABLE IF NOT EXISTS yvdb_login_users (id integer primary key, server_id integer, " +
            " user_uuid text, device_uuid text, access_token text, app_uuid text, app_name text, app_key text, " +
            " app_secret text, show_badge integer, mute_notification integer, silence_notification integer, " +
            " android_notification_type text, login_time integer, logout_time integer, is_online integer)";
        
        _exec(_yvdb, _sql, [], null, null);
    }


    function _update_yvdb(cb) {
        var _sql0 = "PRAGMA user_version";
        var _sql1 = "PRAGMA user_version = 1";
        var _sql2 = "PRAGMA user_version = 2";

        if (yvSys.in_electron()) {
            _create_servers(cb);            
            _create_login_user();
            return;
        }

        _exec(_yvdb, _sql0, [], function (tx, res) {
            var _v = res.rows.item(0).user_version;
            _create_servers(cb); // alway try to create new server
            if (_v === 0) {
                console.log("NO DB -> create now.");
                _create_login_user();
                _exec(_yvdb, _sql1, [], null, null);
            } else if (_v === 1) {
                console.log("HAS DB and updated.");
            }
        }, null);
    }


    function _init_yvdb(callback) {
        _open_yvdb();
        _update_yvdb(function () {
            _pick_user(callback);
        });
    }


    function _add_login_user(user, app, cb) {
        var _sql0 = "SELECT id FROM yvdb_login_users WHERE server_id = ? AND user_uuid = ?";
        var _sql1 = "INSERT INTO yvdb_login_users (server_id, user_uuid, device_uuid, access_token, app_uuid, " +
            " app_name, app_key, app_secret, show_badge, mute_notification, silence_notification, " +
            " android_notification_type, login_time, is_online) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        var _sql2 = "UPDATE yvdb_login_users SET device_uuid = ?, access_token = ?, app_uuid = ?, app_name = ?, " +
            " app_key = ?, app_secret = ?, show_badge = ?, mute_notification = ?, silence_notification = ?, " +
            " login_time = ?, is_online = ? WHERE id = ?";
        
        var _td = Math.round(Date.now() / 1000);
        var _show_badge = user.show_badge ? 1 : 0;
        var _mute_notification = user.mute_notification ? 1 : 0;
        var _silence_notification = user.silence_notification ? 1 : 0;
        var _android_notification_type = yvUser.get("android_notification_type");
        var _values0 = [_current_server.id, user.uuid];
        var _values1 = [_current_server.id, user.uuid, user.device_uuid, user.access_token, app.uuid, app.app_name,
                        app.app_key, app.app_secret, _show_badge, _mute_notification, _silence_notification,
                        _android_notification_type, _td, 1];
        
        function __success(id) {
            yvUser.set("id", id);
            cb && cb();
        }

        _exec(_yvdb, _sql0, _values0, function (tx, res) {
            if (res.rows.length === 0) {
                _exec(_yvdb, _sql1, _values1, function (tx, res) {
                    __success(res.insertId);
                }, null);
                return;
            }
            
            var _id = res.rows.item(0).id;
            var _values2 = [user.device_uuid, user.access_token, app.uuid, app.app_name, app.app_key, app.app_secret, _show_badge,
                            _mute_notification, _silence_notification, _td, 1, _id];

            _exec(_yvdb, _sql2, _values2, function (tx, res) {
                __success(_id);
            }, null);
        }, null);
    }


    function _logout_user(_cb) {
        var _sql = "UPDATE yvdb_login_users SET is_online = 0, logout_time = ? WHERE id = ?";
        var _values = [Math.round(Date.now() / 1000), yvUser.get("id")];

        _exec(_yvdb, _sql, _values, function (tx, res) {
            _cb && _cb();
        }, null);
    }


    function _update_noti_settings(key, value) {
        var _sql = "update yvdb_login_users set " + key + " = ? where id = ?";
        var _values = [value ? 1 : 0, yvUser.get("id")];
        
        _exec(_yvdb, _sql, _values, null, null);
    }

    function _update_android_notification_type(value) {
        var _sql = "update yvdb_login_users set android_notification_type = ? where id = ?";
        var _values = [value, yvUser.get("id")];
        
        _exec(_yvdb, _sql, _values, null, null);
    }

    
    function _query_server() {
        var _sql = "SELECT * FROM yvdb_servers WHERE is_selected = ?";

        _exec(_yvdb, _sql, [1], function (tx, res) {
            var _o = null;
            if (res.rows.length === 1) {
                _o = res.rows.item(0);
                _set_server(_o);
            } else {
                _current_server = {id: -1};
                yvAPI.set_server(_current_server);
            }
        }, null);
    }


    function _query_servers(_cb) {
        var _sql = "select * from yvdb_servers";

        _exec(_yvdb, _sql, [], function (tx, res) {
            var len = res.rows.length, _oa = [], _o, i;

            for (i = 0; i < len; i++) {
                _o = angular.copy(res.rows.item(i));
                _oa.push(_o);
            }

            if (_cb) { _cb(_oa); }
        }, null);
    }


    function _select_server(_server, _cb) {
        var _sql = "update yvdb_servers set is_selected = case when id=? then 1 else 0 end";
        _exec(_yvdb, _sql, [_server.id], _cb, null);
    }


    function _delete_server(_server, _cb) {
        var _sql1 = "delete from yvdb_servers where id=?";
        _exec(_yvdb, _sql1, [_server.id], _cb, null);
    }


    function _add_server(_server, _cb) {
        var _sql0 = "insert into yvdb_servers (name, host, port, protocol, is_selected) values (?, ?, ?, ?, ?)",
            _sql1 = "update yvdb_servers set is_selected = case when id=? then 1 else 0 end",
            _selected = _server.select ? 1 : 0,
            _values0 = [_server.name, _server.host, _server.port, _server.protocol, _selected];

        _exec(_yvdb, _sql0, _values0, function (tx, res) {
            if (_server.select) {
                _exec(_yvdb, _sql1, [res.insertId], function (tx, res) {
                    if (_cb) { _cb(); }
                }, null);
            } else {
                if (_cb) { _cb(); }
            }
        }, null);
    }


    function _open_userdb(uuid) {
        var app_key = yvUser.get("app").app_key;
        var db_name = hex_sha1(uuid + app_key);

        try {
            _userdb = _open_db(db_name);
        } catch (error) {
            console.error("encount error when init userdb", error);
        }

        return _userdb;
    }


    function _create_userdb(cb) {
        // uncomment this to drop tables
        // _exec(_userdb, "drop table if exists userdb_objects", [], null, null);
        // _exec(_userdb, "drop table if exists userdb_messages", [], null, null);
        // _exec(_userdb, "drop table if exists userdb_conversations", [], null, null);
        // _exec(_userdb, "drop table if exists userdb_contacts", [], null, null);
        var _sql0 = "CREATE TABLE IF NOT EXISTS userdb_objects (id integer primary key, type text, uuid text unique, " +
            " name text, fullname text, signature text, email text, icon text, updatetime integer)";

        var _sql1 = "CREATE TABLE IF NOT EXISTS userdb_messages (id integer primary key, conversation_uuid text, task_uuid text, " +
            " push_uuid text, from_uuid text, to_uuid text, to_type text, type text, subtype text, title text, body text, file text, " +
            " size integer, name text, mime text, duration integer, thumbnail text, direction text, status text, timestamp integer)";

        var _sql2 = "CREATE TABLE IF NOT EXISTS userdb_conversations (id integer primary key, uuid text unique, " +
            " name text, icon text, type text, assigned_uuid text, user_uuid text, group_uuid text, unread integer)";

        var _sql3 = "CREATE TABLE IF NOT EXISTS userdb_contacts (id integer primary key, uuid text unique, " +
            " is_portal_user boolean, is_service_user boolean)";

        _exec(_userdb, _sql0, [], null, null);
        _exec(_userdb, _sql1, [], null, null);
        _exec(_userdb, _sql2, [], null, null);
        _exec(_userdb, _sql3, [], null, null);
        cb && cb();
    }


    function _update_userdb(cb) {
        var _sql0 = "PRAGMA user_version";
        var _sql1 = "PRAGMA user_version = 1";

        if (yvSys.in_electron()) {
            _create_userdb(cb);
            return;
        }

        _exec(_userdb, _sql0, [], function (tx, res) {
            var version = res.rows.item(0).user_version;
            if (version === 0) {
                console.log("NO USERDB -> create now.");
                _create_userdb(cb);
                _exec(_userdb, _sql1, [], null, null);
                return;
            }
            if (version === 1) {
                console.log("HAS USERDB and updated.");
                cb && cb();
                return;
            }
        }, null);
    }


    function _init_userdb(uuid, callback) {
        _open_userdb(uuid);
        _update_userdb(callback);
    }


    function _is_conversation_existed(_uuid, _yes, _no) {
        var _sql = "SELECT uuid FROM userdb_conversations WHERE uuid = ?";

        _exec(_userdb, _sql, [_uuid], function (tx, res) {
            if (res.rows.length) {
                _yes && _yes();
            } else {
                _no && _no();
            }
        });
    }


    function _insert_conversation(conv, _cb) {
        var _sql = "INSERT INTO userdb_conversations (uuid, name, icon, type, assigned_uuid, user_uuid, group_uuid, unread) " +
            " VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
        var _value = [conv.uuid, conv.name, conv.icon, conv.type, conv.assigned_uuid, conv.user_uuid, conv.group_uuid, conv.unread];

        _exec(_userdb, _sql, _value, _cb, null);
    }


    function _update_conversation_unread(conv, _cb) {
        var _sql = "UPDATE userdb_conversations SET unread = ? WHERE uuid = ?";
        var _value = [conv.unread, conv.uuid];

        _exec(_userdb, _sql, _value, _cb, null);
    }


    function _update_conversation_group(conv, _cb) {
        var _sql = "UPDATE userdb_conversations SET group_uuid = ? WHERE uuid = ?";
        var _value = [conv.group_uuid, conv.uuid];

        _exec(_userdb, _sql, _value, _cb, null);
    }


    // only for add conversation after getting app conversations from server
    function _add_conversation(conv) {
        _is_conversation_existed(conv.uuid, function () {
            console.log("conversation already exists in database, will not add.", conv);
        }, function () {
            _insert_conversation(conv);
        });
    }


    function _delete_conversation(_conv) {
        var _sql0 = "DELETE FROM userdb_messages WHERE conversation_uuid = ?";
        var _sql1 = "DELETE FROM userdb_conversations WHERE uuid = ?";
        
        _exec(_userdb, _sql0, [_conv.uuid], null, null);
        _exec(_userdb, _sql1, [_conv.uuid], null, null);
    }


    function _delete_all_conversations(callback) {
        var _sql = "DELETE FROM userdb_conversations";

        _exec(_userdb, _sql, [], callback, callback);
    }

    function _delete_all_contacts(callback) {
        var _sql = "DELETE FROM userdb_contacts";

        _exec(_userdb, _sql, [], callback, callback);
    }


    function _update_current_user(key, value) {
        var _sql = null, _value = null;
        if (arguments.length === 0) {
            _sql = "UPDATE userdb_objects SET fullname = ?, icon = ?, signature = ? WHERE uuid = ?";
            _value = [yvUser.get("fullname"), yvUser.get("icon"), yvUser.get("signature"), yvUser.get("uuid")];
        } else {
            _sql = "UPDATE userdb_objects SET " + key + " = ? WHERE uuid = ?";
            _value = [value, yvUser.get("uuid")];
        }
        
        _exec(_userdb, _sql, _value, null, null);
    }


    function _is_object_existed(_uuid, _yes, _no) {
        var _sql = "SELECT * FROM userdb_objects WHERE uuid = ?";

        _exec(_userdb, _sql, [_uuid], function (tx, res) {
            if (res.rows.length) {
                _yes && _yes();
            } else {
                _no && _no();
            }
        }, null);
    }


    function _update_object(data) {
        var _sql = "UPDATE userdb_objects SET icon = ?, fullname = ?, signature = ?, " +
            " name = ?, email = ?, updatetime = ? WHERE uuid = ?";
        var _values = [data.icon, data.fullname, data.signature, data.name, data.email, data.updatetime, data.uuid];

        _exec(_userdb, _sql, _values, null, null);
    }


    function _insert_object(_data) {
        var _sql = "INSERT INTO userdb_objects (uuid, type, icon, signature, " +
            " fullname, name, email, updatetime) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
        var _type = _data.type || yvConstants.YVOBJECT.DEVICE_USER;
        var _values = [_data.uuid, _type, _data.icon, _data.signature, _data.fullname, _data.name,
                       _data.email, _data.updatetime];
        
        _exec(_userdb, _sql, _values, null, null);
    }


    function _add_object(object) {
        _is_object_existed(object.uuid, function () {
            _update_object(object);
        }, function () {
            _insert_object(object);
        });
    }


    function _add_contact(contact) {
        var _sql0 = "SELECT id FROM userdb_contacts WHERE uuid = ?";
        var _sql1 = "INSERT INTO userdb_contacts (uuid, is_portal_user, is_service_user) VALUES (?, 0, 1)";

        _exec(_userdb, _sql0, [contact.uuid], function (tx, res) {
            if (res.rows.length === 0) {
                _exec(_userdb, _sql1, [contact.uuid], null, null);
            }
        }, null);
    }


    function _query_messages(conv_uuid, success, error) {
        var _sql = "SELECT * FROM userdb_messages WHERE conversation_uuid = ? ORDER BY timestamp, id LIMIT 12";

        _exec(_userdb, _sql, [conv_uuid], function (tx, res) {
            success && success(res);
        }, function (tx, err) {
            error && error(err);
        });
    }


    function _insert_message(msg, callback) {
        var _sql0 = "SELECT task_uuid FROM userdb_messages WHERE task_uuid = ? AND direction = ?";
        var _sql1 = "INSERT INTO userdb_messages ( conversation_uuid, task_uuid, push_uuid, from_uuid, to_uuid, to_type, type, " +
            " subtype, title, body, file, size, mime, name, duration, thumbnail, direction, status, timestamp) " +
            " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        var _value0 = [msg.task_uuid, msg.direction];
        var _value1 = [msg.conversation_uuid, msg.task_uuid, msg.push_uuid, msg.from_uuid, msg.to_uuid, msg.to_type,
                       msg.type, msg.subtype, msg.title, msg.body, msg.file, msg.size, msg.mime, msg.name, msg.duration,
                       msg.thumbnail, msg.direction, msg.status, msg.timestamp];

        _exec(_userdb, _sql0,  _value0, function (tx, res) {
            if (res.rows.length) {
                console.log("msg is duplicated task_uuid: " + msg.task_uuid);
                msg.id = res.rows.item(0).id;
                callback && callback(msg);
                return;
            }

            _exec(_userdb, _sql1, _value1, function (tx, res) {
                msg.id = res.insertId;
                callback && callback(msg);
            }, null);
        }, null);
    }


    function _delete_message(_message) {
        var _sql = "DELETE FROM userdb_messages WHERE id = ?";

        _exec(_userdb, _sql, [_message.id], null, null);
    }


    function _update_message_all(_message) {
        var _sql = 'UPDATE userdb_messages SET status = ?, task_uuid = ?, timestamp = ? WHERE id = ?';
        var _value = [_message.status, _message.task_uuid, _message.timestamp, _message.id];

        _exec(_userdb, _sql, _value, null, null);
    }


    function _update_message_status(_message) {
        var _sql = 'UPDATE userdb_messages SET status = ? WHERE id = ?';

        _exec(_userdb, _sql, [_message.status, _message.id], null, null);
    }


    function _update_message_file(_message) {
        var _sql = 'UPDATE userdb_messages SET file = ? WHERE id = ?';

        _exec(_userdb, _sql, [_message.file, _message.id], null, null);
    }


    function _unread_zero(_conv_uuid) {
        var _sql0 = "UPDATE userdb_conversations SET unread = 0 WHERE uuid = ?";
        var _sql1 = "UPDATE userdb_messages SET status = ? WHERE conversation_uuid = ? AND status = ?";
        var _value1 = [yvConstants.RECV_STATUS.RECV_OPEN, _conv_uuid, yvConstants.RECV_STATUS.RECV_NEW];

        _exec(_userdb, _sql0, [_conv_uuid], null, null);
        _exec(_userdb, _sql1, _value1, null, null);
    }


    function _set_audio_read(_id, _cb) {
        var _sql = "UPDATE userdb_messages SET status = ? WHERE id = ?";

        _exec(_userdb, _sql, [yvConstants.RECV_STATUS.RECV_PLAY, _id], _cb, null);
    }


    function _get_latest_message(conversation, callback) {
        var _sql = "SELECT * FROM userdb_messages WHERE conversation_uuid = ? ORDER BY TIMESTAMP DESC LIMIT 1";

        _exec(_userdb, _sql, [conversation.uuid], function (tx, res) {
            callback && callback(res.rows.item(0), conversation);
        }, null);
    }


    function _load_common(_sql, success, error) {
        _exec(_userdb, _sql, [], function (tx, res) {
            success && success(tx, res);
        }, function (tx, err) {
            error && error(tx, err);
        });
    }

    function _load_contacts(success, error) {
        var _sql = "SELECT * FROM userdb_contacts LEFT JOIN userdb_objects WHERE userdb_contacts.uuid = userdb_objects.uuid";

        _load_common(_sql, success, error);
    }


    function _load_objects(success, error) {
        var _sql = "SELECT * FROM userdb_objects ORDER BY fullname";

        _load_common(_sql, success, error);
    }


    function _load_conversations(success, error) {
        var limit = yvSys.page_size();
        var _sql = "SELECT * FROM userdb_conversations ORDER BY unread DESC limit " + limit;

        _load_common(_sql, success, error);
    }

    return {
        init_yvdb: function (cb) {
            return _init_yvdb(cb);
        },

        init_userdb: function (_uuid, _cb) {
            return _init_userdb(_uuid, _cb);
        },

        query_server: function () {
            return _query_server();
        },

        query_servers: function (_cb) {
            return _query_servers(_cb);
        },

        select_server: function (_server, _cb) {
            return _select_server(_server, _cb);
        },

        add_server: function (_server, _cb) {
            return _add_server(_server, _cb);
        },

        delete_server: function (_server, _cb) {
            return _delete_server(_server, _cb);
        },

        logout_user: function (cb) {
            return _logout_user(cb);
        },

        add_login_user: function (user, app, cb) {
            return _add_login_user(user, app, cb);
        },

        add_conversation: function (conversation) {
            return _add_conversation(conversation);
        },

        update_conversation_unread: function (conversation) {
            return _update_conversation_unread(conversation);
        },

        update_conversation_group: function (conversation) {
            return _update_conversation_group(conversation);
        },

        add_contact: function (contact) {
            return _add_contact(contact);
        },

        add_object: function (object) {
            return _add_object(object);
        },

        load_contacts: function (success, error) {
            return _load_contacts(success, error);
        },

        load_objects: function (success, error) {
            return _load_objects(success, error);
        },

        load_conversations: function (success, error) {
            return _load_conversations(success, error);
        },

        query_messages: function (conv_uuid, success, error) {
            return _query_messages(conv_uuid, success, error);
        },

        insert_message: function (message, callback) {
            _insert_message(message, callback);
        },

        delete_message: function (_message) {
            return _delete_message(_message);
        },

        delete_conversation: function (_conv) {
            return _delete_conversation(_conv);
        },

        delete_all_conversations: function (callback) {
            return _delete_all_conversations(callback);
        },

        delete_all_contacts: function (callback) {
            return _delete_all_contacts(callback);
        },

        update_message_all: function (_message) {
            return _update_message_all(_message);
        },

        update_message_status: function (_message) {
            return _update_message_status(_message);
        },

        update_message_file: function (_message) {
            return _update_message_file(_message);
        },

        set_audio_read: function (_id, _cb) {
            return _set_audio_read(_id, _cb);
        },

        get_latest_message: function (_conv, _cb) {
            return _get_latest_message(_conv, _cb);
        },

        update_current_user: function (key, value) {
            return _update_current_user(key, value);
        },

        update_noti_settings: function (key, value) {
            return _update_noti_settings(key, value);
        },

        update_android_notification_type: function (key, value) {
            return _update_android_notification_type(key, value);
        },

        unread_zero: function (_conv_uuid) {
            return _unread_zero(_conv_uuid);
        }
    };
}]);

ppmessageModule.factory("yvNoti", [
    "$timeout",
    "$rootScope",
    "yvAPI",
    "yvSys",
    "yvSSL",
    "yvUser",
    "yvLink",
    "yvType",
    "yvAlert",
    "yvLocal",
    "yvBase",
    "yvMessage",
    "yvConstants",
function ($timeout, $rootScope, yvAPI, yvSys, yvSSL, yvUser, yvLink, yvType, yvAlert, yvLocal, yvBase, yvMessage, yvConstants) {
    
    var SOCKET_STATE = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var _pc_socket = null;
    var _typing_promise = null;
    var _reconnect_interval = null;
    var _pending_messages = [];

    function _on_resume() {
        $timeout(function () {
            __open_socket();
        });
    }

    function _on_pause() {
        $timeout(function() {
            __close_socket();
        });
    }
        
    function _socket_reconnect_interval() {
        var _d = new Date(), _s = _socket_reconnect();
        // console.log("SOCKET RECONNECT AT: ", _d.toUTCString(), "CURRENT STATE IS: ", _s);
    }
    
    function _is_socket_type_data(data) {
        if (data.type !== undefined) {
            return true;
        }
        return false;
    }
    
    function _is_socket_meta_data(data) {
        if (data.error_code !== undefined) {
            return true;
        }
        return false;
    }
    
    function _is_socket_message_data(data) {
        // message type and message subtype
        if (data.mt !== undefined && data.ms !== undefined) {
            return true;
        }
        return false;
    }

    function _handle_socket_meta_data(obj) {
    }

    function _handle_socket_type_data(obj) {
        //FIXME: online message
        //FIXME: typing message

        if (obj.type == "ONLINE" || obj.type == "TYPING") {
            return;
        }
        
        if (obj.type == "MSG") {
            _handle_socket_message_data(obj.msg);
            return;
        }

        if (obj.type == "ACK") {
            $rootScope.$broadcast("event:receive_ack_message", obj);
            return;
        }

        //console.error("unknown ws message: %o", obj)
        return;
    }
    
    function _handle_socket_message_data(obj) {
        $rootScope.$broadcast("event:add_message", obj);
    }

    function __open_socket() {
        _socket_init();
        _reconnect_interval = setInterval(_socket_reconnect_interval, 1000 * 10);
    }
    
    function __close_socket() {
        
        if (_pc_socket != null) {
            _pc_socket.close();
            _pc_socket = null;
        }
        
        if (_reconnect_interval != null) {
            clearInterval(_reconnect_interval);
            _reconnect_interval = null;
        }
    }
        
    function _fn_pc_open() {
        if (!_pc_socket) {
            console.error("there is no pc socket");
            return;
        }

        var _socket_state = _pc_socket.readyState;
        var _auth = {
            type: "auth",
            is_service_user: true,
            api_token: yvUser.get("access_token"),
            user_uuid: yvUser.get("uuid"),
            device_uuid: yvUser.get("device_uuid"),
            app_uuid: yvUser.get("app").uuid
        };

        if (_socket_state === WebSocket.OPEN) {
            _pc_socket.send(JSON.stringify(_auth));

            // send pending message
            angular.forEach(_pending_messages, function (message) {
                console.log("-------send pending message", message);
                _pc_socket.send(JSON.stringify(message));
            });
            _pending_messages.length = 0;
            return;
        }
        
        console.error("pc socket is not open, current state is: ", SOCKET_STATE[_socket_state]);
        return;
    }

    function _fn_pc_close() {
        console.log("======WS closed==========");
    }

    function _fn_pc_listener(message) {
        var _o = JSON.parse(message.data);

        if (_is_socket_type_data(_o)) {
            _handle_socket_type_data(_o);
            return;
        }
        
        return;
    }

    function _socket_init() {
        var server = yvAPI.get_server();
        var ws = server.protocol == "https://" ? "wss://" : "ws://";
        var host = server.port ? server.host + ":" + server.port : server.host;
        var url = ws + host + "/pcsocket/WS";
        _pc_socket = new WebSocket(url);
        _pc_socket.onopen = _fn_pc_open;
        _pc_socket.onmessage = _fn_pc_listener;
        _pc_socket.onclose = _fn_pc_close;
    }

    function _socket_reconnect() {
        if (!_pc_socket) {
            _socket_init();
            return "NO_SOCKET";
        }
        var _socket_state = _pc_socket.readyState;
        if (_socket_state === WebSocket.CLOSING || _socket_state === WebSocket.CLOSED) {
            console.log("socket_reconnect, socket is closing or closed, will reconnect");
            _socket_init();
        }
        return SOCKET_STATE[_socket_state];
    }

    function _exit() {
        // for every platform
        __close_socket();
    }

    function _send_type_message(_body) {
        if (!_pc_socket || _pc_socket.readyState != WebSocket.OPEN) {
            console.error("send type message failed for socket not open");
            return;
        }
        _pc_socket.send(JSON.stringify(_body));
    }

    function _send_pp_message(_m, _s, _e, _e) {
        if (!_pc_socket || _pc_socket.readyState != WebSocket.OPEN) {
            console.error("send type message failed for socket not open, push it to pending list");
            _pending_messages.push(_m);
            _e && _e();
            return;
        }
        _pc_socket.send(JSON.stringify(_m));
        _s && _s();
        return
    }
    
    return {
        init: function (_success, _error) {
            __close_socket();            
            __open_socket();
        },

        exit: function () {
            _exit();
        },
        
        send_message: function(_m, _s, _e, _e) {
            _send_pp_message(_m, _s, _e, _e);
        },
        
    };
}]);

ppmessageModule.factory('yvUser', [
    "yvSys",
    "yvConstants",
function (yvSys, yvConstants) {
    var user = {
        id: null,
        icon: null,
        name: null,
        uuid: null,
        email: null,
        fullname: null,
        signature: null,
        device_uuid: null,
        updatetime: null,
        is_online: false,
        access_token: null,
        password: null,
        status: yvConstants.USER_STATUS.READY,
        
        app: {
            uuid: "",
            app_key: "",
            app_name: "",
            app_secret: ""
        },

        show_badge: null,
        mute_notification: null,
        silence_notification: null,
        mute_other_mobile_device: null,

        android_notification_type: yvConstants.NOTIFICATION_TYPE.GCM        
    };

    // update user from API/PP_GET_USER_INFO
    function _update_user_from_api(data) {
        user.uuid = data.uuid;
        user.icon = data.user_icon;
        user.name = data.user_name;
        user.email = data.user_email;
        user.fullname = data.user_fullname;
        user.signature = data.user_signature;
        user.updatetime = data.updatetime;
        user.is_online = true;
        user.device_uuid = data.ppkefu_browser_device_uuid;
                       
        return user;
    }

    // update user from API return
    function _update_user_from_login(data) {
        
        user.app = data.app;
        user.uuid = data.uuid;
        user.icon = data.user_icon;
        user.name = data.user_name;
        user.email = data.user_email;
        user.fullname = data.user_fullname;
        user.signature = data.user_signature;
        user.updatetime = data.updatetime;
        user.password = data.user_password;
        user.is_online = true;
        user.status = yvConstants.USER_STATUS.READY;
        user.device_uuid = data.ppkefu_browser_device_uuid;
        
        return user;
    }

    function _update_user_from_db(item) {
        user.id = item.id;
        user.uuid = item.user_uuid;
        user.is_online = !!item.is_online;
        user.device_uuid = item.device_uuid;
        user.access_token = item.access_token;
        
        user.app = {
            uuid: item.app_uuid,
            app_key: item.app_key,
            app_name: item.app_name,
            app_secret: item.app_secret
        };

        user.show_badge = !!item.show_badge;
        user.mute_notification = !!item.mute_notification;
        user.silence_notification = !!item.silence_notification;

        user.android_notification_type = item.android_notification_type || yvConstants.NOTIFICATION_TYPE.GCM;
        return user;
    }
    
    return {
        update_user_from_login: function (_user) {
            return _update_user_from_login(_user);
        },

        update_user_from_api: function (_data) {
            return _update_user_from_api(_data);
        },

        update_user_from_db: function (item) {
            return _update_user_from_db(item);
        },

        set: function (attribute, value) {
            if (user.hasOwnProperty(attribute)) {
                user[attribute] = value;
            }
        },

        mset: function (data) {
            angular.forEach(data, function (value, key) {
                if (user.hasOwnProperty(key)) {
                    user[key] = value;
                }
            });
        },

        get: function (attribute) {
            if (arguments.length === 0) {
                return user;
            }
            if (user.hasOwnProperty(attribute)) {
                return user[attribute];
            }
            return null;
        },
    };
}]);

ppmessageModule.factory('yvSend', [
    "$rootScope",
    "yvConstants",
    "yvNoti",
    "yvMessage",
function ($rootScope, yvConstants, yvNoti, yvMessage) {

    function _send_message(_message, _is_forward) {
        
        // send message to server or forward this message
        var _api_message = null;
        
        function __success() {
            var status = yvConstants.SEND_STATUS.SEND_SUCCESS;
            $rootScope.$broadcast("event:update_message_status", _message, status);
        }

        function __error() {
            var status = yvConstants.SEND_STATUS.SEND_ERROR;
            $rootScope.$broadcast("event:update_message_status", _message, status);
        }

        if (_is_forward === true) {
            _api_message = yvMessage.create_api_forward_message(_message);
            yvAPI.forward_message(_api_message, __success, __error);
        } else {
            _api_message = yvMessage.create_api_send_message(_message);
            var _ws_message = {
                type:"send",
                send:_api_message
            };
            yvNoti.send_message(_ws_message, __success, __error);
        }
    }
    
    return {
        send_message: function(_message, _is_forward) {
            _send_message(_message, _is_forward);
        },
        
    };
}]);

ppmessageModule.factory('yvMessage', [
    "$timeout",
    "yvSys",
    "yvUser",
    "yvFile",
    "yvType",
    "yvLocal",
    "yvConstants",
function ($timeout, yvSys, yvUser, yvFile, yvType, yvLocal, yvConstants) {

    function Message(task_uuid) {
        this.task_uuid = task_uuid;

        if (typeof this.from_uuid !== "string") {
            Message.prototype.to_uuid = "";
            Message.prototype.to_type = "";
            Message.prototype.from_uuid = "";
            Message.prototype.push_uuid = "";
            Message.prototype.conversation_uuid = "";

            Message.prototype.is_history = false;

            Message.prototype.id = 0;
            Message.prototype.size = 0;
            Message.prototype.type = "";
            Message.prototype.body = "";
            Message.prototype.file = "";
            Message.prototype.name = "";
            Message.prototype.mime = "";
            Message.prototype.title = "";
            Message.prototype.status = "";
            Message.prototype.duration = 0;
            Message.prototype.subtype = "";
            Message.prototype.timestamp = 0;
            Message.prototype.thumbnail = "";
            Message.prototype.direction = "";
        }
    }

    function _new_message(task_uuid) {            
        if (!task_uuid) {
            task_uuid = yvSys.get_uuid();
        }
        var message = new Message(task_uuid);
        return message;
    }

    
    function _get_real_direction(from_uuid, to_uuid) {
        var _direction = yvConstants.MESSAGE_DIR.DIR_IN;
        if (from_uuid === yvUser.get("uuid")) {
            // this is a sync message from another device
            _direction = yvConstants.MESSAGE_DIR.DIR_OUT;
        }
        return _direction;
    }

    function _get_real_status(from_uuid, to_uuid) {
        var _status = yvConstants.RECV_STATUS.RECV_NEW;
        if (from_uuid === yvUser.get("uuid")) {
            // this is a sync message from another device
            _status = yvConstants.SEND_STATUS.SEND_SUCCESS;
        }
        return _status;
    }

    function _get_raw_title(_body, _subtype) {
        var type = yvConstants.MESSAGE_SUBTYPE;

        switch (_subtype) {
        case type.TEXT:
            return _body;
        case type.IMAGE:
            return "app.GLOBAL.TITLE_IMAGE";
        case type.FILE:
            return "app.GLOBAL.TITLE_FILE";
        case type.LOGOUT:
            return "app.GLOBAL.TITLE_LOGOUT";
        default:
            console.error("unknown message subtype", _subtype);
            return "app.GLOBAL.TITLE_UNKNOWN";
        }
    }

    function _get_standard_message(raw_message) {
        var message = _new_message(raw_message.ci);
        
        message.to_uuid = raw_message.ti;
        message.to_type = raw_message.tt;
        message.from_uuid = raw_message.fi;
        message.from_type = raw_message.ft;
        message.task_uuid = raw_message.id;
        message.push_uuid = raw_message.pid;
        message.from_user = raw_message.from_user;
        message.conversation_uuid = raw_message.ci;

        message.body = raw_message.bo;        
        message.type = raw_message.mt;
        message.subtype = raw_message.ms;
        message.timestamp = raw_message.ts;
        
        message.title = _get_raw_title(raw_message.bo, raw_message.ms);
        message.status = _get_real_status(raw_message.fi, raw_message.ti);
        message.direction = _get_real_direction(raw_message.fi, raw_message.ti);
        
        return message;
    }

    function _create_api_send_message(_message) {
        if (yvType.is_file(_message)) {
            return _file_api_message(_message);
        }
        
        if (yvType.is_image(_message)) {
            return _image_api_message(_message);
        }

        if (yvType.is_text(_message)) {
            return _text_api_message(_message);
        }

        console.log("create_api_message can not handle message: ", _message);
        return null;
    }

    function _real_api_message(_message, _body) {
        var _m = {
            "uuid": _message.task_uuid,
            "app_uuid": yvUser.get("app").uuid,
            "to_uuid": _message.to_uuid,
            "to_type": _message.to_type,
            "from_uuid": yvUser.get("uuid"),
            "from_type": yvConstants.YVOBJECT.DEVICE_USER,
            "device_uuid": yvUser.get("device_uuid"),
            "message_type": _message.type,
            "message_subtype": _message.subtype,
            "conversation_uuid": _message.conversation_uuid,
            "conversation_type": _message.conversation_type,
            "message_body": _body ? JSON.stringify(_body) : _message.body
        };
        return _m;
    }

    function _file_api_message(_message) {
        var _body = {fid: _message.file, mime: _message.mime, name: _message.name};
        return _real_api_message(_message, _body);
    }
    
    function _image_api_message(_message) {
        var _body = {fid: null, mime: _message.mime};
        _body.fid = _message.file;
        return _real_api_message(_message, _body);
    }


    function _text_api_message(_message) {
        return _real_api_message(_message);
    }

    function _txt_api_message(_message) {
        var _body = {fid: null};
        _body.fid = _message.file;
        return _real_api_message(_message, _body);
    }

    function _string_to_ts(_str) {
        // Safari doesn't understand yyyy-mm-dd,
        // Chrome understands both yyyy-mm-dd and yyyy/mm/dd
        var _f = "yyyy/MM/dd HH:mm:ss",
            _s = _str.slice(0, _f.length).replace(/-/g, "/");
        return Date.parse(_s) / 1000;
    }

    function _history_message(raw_message) {
        var msg = _new_message(raw_message.uuid);
        body = angular.fromJson(raw_message.message_body);
        if (!body) {
            return msg;
        }

        msg.is_history = true;
        msg.body = body.bo;
        msg.type = body.mt;
        msg.subtype = body.ms;
        msg.to_uuid = body.ti;
        msg.to_type = body.tt;
        msg.from_uuid = body.fi;
        msg.id = yvSys.get_uuid();
        msg.conversation_uuid = body.ci;
        msg.timestamp = body.ts;
        msg.title = _get_raw_title(body.bo, body.ms);
        
        if (body.fi === yvUser.get("uuid") && body.tt !== yvConstants.CONVERSATION_TYPE.P2S) {
            msg.direction = yvConstants.MESSAGE_DIR.DIR_OUT;
            msg.status = yvConstants.SEND_STATUS.SEND_SUCCESS;
        } else {
            msg.direction = yvConstants.MESSAGE_DIR.DIR_IN;
            msg.status = yvConstants.RECV_STATUS.RECV_OPEN;
        }

        return msg;
    }

    function _create_sending_message(conversation, raw_message) {
        var _message = _new_message();
        var _data = raw_message.data;
        var _subtype = raw_message.type;

        _message.subtype = _subtype;
        _message.type = yvConstants.MESSAGE_TYPE.NOTI;
        _message.title = _get_raw_title(_data, _subtype);
        _message.timestamp = Date.now() / 1000;
        _message.direction = yvConstants.MESSAGE_DIR.DIR_OUT;
        _message.status = yvConstants.SEND_STATUS.SEND_PENDING;

        _message.from_uuid = yvUser.get("uuid");
        _message.to_uuid = conversation.user_uuid;
        _message.conversation_uuid = conversation.uuid;
        _message.conversation_type = conversation.type;
        _message.to_type = yvConstants.YVOBJECT.DEVICE_USER;

        if (conversation.type == yvConstants.CONVERSATION_TYPE.P2S) {
            _message.conversation_type = yvConstants.CONVERSATION_TYPE.S2P;
        }

        if (conversation.latest_message && conversation.latest_message.timestamp > _message.timestamp) {
            _message.timestamp = conversation.latest_message.timestamp + 1;
        }

        if (yvType.is_text(_message)) {
            return _sending_text_message(_message, _data);
        }

        if (yvType.is_image(_message)) {
            return _sending_image_message(_message, _data);
        }

        if (yvType.is_file(_message)) {
            return _sending_file_message(_message, _data);
        }
        
        console.error("unknown message:", raw_message);
        return null;
    }

    function _sending_text_message(message, data) {
        message.body = data;
        return message;
    }

    function _sending_image_message(message, data) {
        message.file = data.file;
        message.name = data.name;
        message.size = data.size;
        message.mime = data.mime;
        return message;
    }

    function _sending_file_message(message, data) {
        message.name = data.name;
        message.size = data.size;
        message.mime = data.mime;
        return message;
    }

    return {

        // create sending message for api service based on db record
        create_api_send_message: function (_message) {
            return _create_api_send_message(_message);
        },

        history_message: function (raw_message) {
            return _history_message(raw_message);
        },

        get_raw_title: function (_body, _subtype) {
            return _get_raw_title(_body, _subtype);
        },

        localize_title: function (_raw_title) {
            return yvLocal.translate(_raw_title);
        },

        get_localized_title: function (_body, _subtype) {
            var raw_title = _get_raw_title(_body, _subtype);
            var type = yvConstants.MESSAGE_SUBTYPE;
            
            if (_subtype === type.TEXT) {
                return _body;
            }
            return yvLocal.translate(raw_title);
        },

        create_forward_message: function (_forward) {
            var _msg = _forward.message,
                _m = {
                    from_uuid: yvUser.get("uuid"),
                    to_uuid: _forward.conv_uuid,
                    to_type: _forward.conv_type,
                    task_uuid: _msg.task_uuid,
                    conversation_uuid: _forward.conv_uuid,
                    timestamp: Date.now() / 1000,
                    direction: yvConstants.DIR.DIR_OUT,
                    status: yvConstants.SEND_STATUS.SEND_PENDING,
                    type: _msg.type,
                    subtype: _msg.subtype,
                    title: _msg.title,
                    body: _msg.body,
                    duration: _msg.duration,
                    file: _msg.file,
                    name: _msg.name,
                    mime: _msg.mime,
                    size: _msg.size,
                    thumbnail: _msg.thumbnail
                };

            _m.conversation_type = yvConstants.CONVERSATION_TYPE.S2S;
            if (_forward.conv_type == yvConstants.CONVERSATION_TYPE.P2S) {
                _m.to_type = yvConstants.CONVERSATION_TYPE.S2P;
                _m.conversation_type = yvConstants.CONVERSATION_TYPE.S2P;
            }

            return _m;
        },

        create_sending_message: function (conversation, raw_message) {
            return _create_sending_message(conversation, raw_message);
        },

        get_standard_message: function (message) {
            return _get_standard_message(message);
        },

        create_api_forward_message: function (_message) {
            var _data = {
                to_uuid: _message.to_uuid,
                to_type: _message.to_type,
                conversation_type: _message.conversation_type,
                task_uuid: _message.task_uuid
            };
            return _data;
        },

        string_to_ts: function (str) {
            return _string_to_ts(str);
        },

        create: function (task_uuid) {
            return _new_message(task_uuid);
        },

        check_prototype: function (message) {
            if (Message.prototype.isPrototypeOf(messsage)) {
                return true;
            }
            return false;
        },
    };
}]);

ppmessageModule.factory("yvSys", $yvSysService);

$yvSysService.$inject = ["$rootScope", "$state", "$timeout", "$window", "yvLog", "yvConstants"];

function $yvSysService($rootScope, $state, $timeout, $window, yvLog, yvConstants) {
    
    var _page_size = 15;
    var _keyboard_height = 216;
    var _device_online = true;
    var _bundle = {
        id: "",
        display_name: yvConstants.DEFAULT_BUNDLE_NAME
    };
    
    var _p = ionic.Platform;
    var _platform = {
        'isWebView': _p.isWebView(),
        'isIPad': _p.isIPad(),
        'isIOS': _p.isIOS() || _p.isIPad(),
        'isAndroid': _p.isAndroid(),
        'isWindowsPhone': _p.isWindowsPhone(),
        'platform': _p.platform(),
        'version': _p.version(),
        'device': _p.device()
    };

    if (_platform.isIOS || _platform.isAndroid || _platform.isWindowsPhone) {
        _page_size = Math.floor(screen.height / 72);
    }

    function _is_document_visible() {
        var hidden, state, visibilityChange; 
        if (typeof document.hidden !== "undefined") {
	        hidden = "hidden";
	        visibilityChange = "visibilitychange";
	        state = "visibilityState";
        } else if (typeof document.mozHidden !== "undefined") {
	        hidden = "mozHidden";
	        visibilityChange = "mozvisibilitychange";
	        state = "mozVisibilityState";
        } else if (typeof document.msHidden !== "undefined") {
	        hidden = "msHidden";
	        visibilityChange = "msvisibilitychange";
	        state = "msVisibilityState";
        } else if (typeof document.webkitHidden !== "undefined") {
	        hidden = "webkitHidden";
	        visibilityChange = "webkitvisibilitychange";
	        state = "webkitVisibilityState";
        }

        if (!state ) {
            return false;
        }
        
        if (document[state] === "visible") {
            return true;
        }
        
        return false;
    }
    
    function _request_desktop_notification() {
        if (window.Notification === undefined) {
            console.error("No Notification support.");
            return;
        }

        if (Notification.permission !== "granted") {
            Notification.requestPermission(function (status) {
                if (Notification.permission !== status) {
                    Notification.permission = status;
                }
            });
        }
    }

    function _desktop_notification(_message) {
        var _option = null, _noti = null;

        _request_desktop_notification();

        if (window.Notification && Notification.permission !== "granted") {
            console.error("Needs Notification permission.");
            return;
        }

        if (window.Notification && Notification.permission === "granted") {
            _option = {
                body: _message.body,
                icon: _message.icon
            };
            
            if (_is_document_visible()) {
                return;
            }
            
            _noti = new Notification(_message.title, _option);
            _noti.onclick = function() {
                window.focus();
                $rootScope.$broadcast("event:open-conversation", {
                    conv_uuid: _message.conversation_uuid,
                    conv_type: _message.conversation_type
                });
            };
            
            setTimeout(_noti.close.bind(_noti), 3000);
        }
        return;
    }

    function _get_uuid() {
        var d, uuid;
        d = new Date().getTime();
        uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === 'x' ? r : (r & 0x7 | 0x8)).toString(16);
        });
        return uuid;
    }

    function _set_device_uuid_cookie(name) {
        return _get_uuid();
    }

    // should fix the bug: download won't start in firefox
    // when download link is clicked
    function _click_download(href, filename) {
        var link = document.createElement("a");
        var event = new MouseEvent("click", {
            "view": window,
            "bubbles": true,
            "cancelable": true
        });
        if (filename) {
            link.download = filename;
        }
        link.href = href;
        link.dispatchEvent(event);
    }

    function _read_image_file(file, success, error) {
        reader = new FileReader();
        reader.onload = function(event) {
            $timeout(function () {
                success && success(event.target.result);
            });
        };
        reader.onerror = function (err) {
            error && error(err);
        }
        reader.readAsDataURL(file);
    }
    
    return {
        // running in a mobile device, iphone, ipad, android, windows phone .etc
        in_mobile: function () {
            return this.in_mobile_app() || this.in_mobile_browser();
        },
        
        // running in a mobile device, and is a cordova app
        in_mobile_app: function () {
            return _platform.isWebView;
        },

        // running in a mobile browser
        in_mobile_browser: function () {
            return jscd.mobile && !_platform.isWebView;
        },

        // running in browser, either in mobile or in pc
        in_browser: function () {
            return this.in_pc_browser() || this.in_mobile_browser();
        },

        // running in pc browser
        in_pc_browser: function () {
            return !jscd.mobile && !window.require;
        },

        // running in pc (mac, win, linux), either in browser or in electron
        in_pc: function () {
            return this.in_pc_browser() || this.in_electron();
        },
        
        // based in sqllite plugin, either a cordova app or electron app
        has_db: function () {
            return this.in_mobile_app() || this.in_electron();
        },

        // running in electron
        in_electron: function() {
            return window.require && process && process.versions && process.versions.electron;
        },
        
        /* mobile app begin */
        // a cordova app, running in iOS
        in_ios_app: function () {
            return this.in_mobile_app() && _platform.isIOS;
        },
        
        // a cordova app, running in Android
        in_android_app: function () {
            return this.in_mobile_app() && _platform.isAndroid;
        },
        
        // a cordova app, running in windows phone
        in_wp_app: function () {
            return this.in_mobile_app() && _platform.isWindowsPhone;
        },
        
        /* mobile app end */

        /* mobile browser begin */

        // running in iOS browser
        in_ios_browser: function () {
            return this.in_mobile_browser() && _platform.isIOS;
        },

        // running in Android browser
        in_android_browser: function () {
            return this.in_mobile_browser() && _platform.isAndroid;
        },

        // running in windows phone browser
        in_wp_browser: function () {
            return this.in_mobile_browser() && _platform.isWindowsPhone;
        },        
        /* mobile browser end */
        
        /* pc browser begin */        
        // runnign in windows browser
        in_win_browser: function () {
            return this.in_pc_browser() && jscd.os.indexOf("Win") === 0;
        },

        // running in mac os x browser
        in_mac_browser: function () {
            return this.in_pc_browser() && jscd.os.indexOf("Mac") === 0;
        },

        // running in linux browser
        in_linux_browser: function () {
            return this.in_pc_browser() && jscd.os.indexOf("Lin") === 0;
        },        
        /* pc browser end */

        /* pc electron begin */
        // running in mac electron
        in_mac_electron: function () {
            return this.in_electron() && process.platform === "darwin";
        },

        // running in win32 electron
        in_win32_electron: function () {
            return this.in_electron() && process.platform === "win32";
        },

        // running in win64 electron
        in_win64_electron: function () {
            return this.in_electron() && process.platform === "win64";
        },

        // running in linux electron
        in_linux_electron: function () {
            return this.in_electron() && process.platform === "linux";
        },
        /* pc electron end */
        
        in_nw: function () {
            return window.require && process && process.versions && !process.versions.electron;
        },

        in_node: function() {
            return window.require && process;
        },

        // get cordova app's bundle info
        get_bundle_info: function () {
            return _bundle;
        },

        // set cordova app's bundle info
        set_bundle_info: function () {
            cordova.getAppVersion.getPackageName(function (name) {
                _bundle.id = name;
            }, null);
            cordova.getAppVersion.getAppName(function (name) {
                _bundle.display_name = name;
            }, null);
        },

        // get device info, offered by ionic
        get_device_info: function () {
            return _platform.device;
        },

        // get unique android device uuid, or null
        get_device_uuid: function (_user_id) {
            return _get_uuid();
        },

        // get device platform
        get_device_platform: function () {
            var P = yvConstants.PLATFORM;
            
            // mobile app
            if (this.in_ios_app()) {
                return P.IOS
            }
            if (this.in_android_app()) {
                return P.ANDROID;
            }
            if (this.in_wp_app()) {
                return P.WIP;
            }
            
            // mobile browser
            if (this.in_ios_browser()) {
                return P.IOS_BROWSER;
            }
            if (this.in_android_browser()) {
                return P.ANDROID_BROWSER;
            }
            if (this.in_wp_browser()) {
                return P.WIP_BROWSER;
            }
            
            // pc electron
            if (this.in_win32_electron()) {
                return P.WIN32;
            }
            if (this.in_win64_electron()) {
                return P.WIN64;
            }
            if (this.in_mac_electron()) {
                return P.MAC;
            }
            if (this.in_linux_electron()) {
                return P.LINUX;
            }

            // pc browser
            if (this.in_win_browser()) {
                return P.WIN_BROWSER;
            }
            if (this.in_mac_browser()) {
                return P.MAC_BROWSER;
            }
            if (this.in_linux_browser()) {
                return P.LINUX_BROWSER;
            }
            
            return _platform.platform.substring(0, 3).toUpperCase();
        },

        // get device model
        get_device_model: function () {
            return _platform.device.model;
        },

        // get device friendly fullname
        get_device_fullname: function () {
            if (this.in_mobile_app()) {
                var deviceName = cordova.plugins.deviceName;
                return deviceName.name;
            }
            return _platform.platform + " " + _platform.version + " " + jscd.browser + " " + jscd.browserVersion;
        },

        // get device version
        get_device_version: function () {
            return _platform.version;
        },

        request_desktop_notification: function () {
            return _request_desktop_notification();
        },

        desktop_notification: function (_title, _body, _icon) {
            return _desktop_notification(_title, _body, _icon);
        },

        get_app_body_style: function () {
            if (this.in_mobile() || this.in_electron()) {
                return {};
            }

            var _top = "0%";
            var _height = "100%";
            var _left = 0;
            var _max_width = 1068;
            var _browser_width = window.innerWidth;
            var _browser_height = window.innerHeight;
            var _style = {
                width: "100%",
                minHeight: "600px",
                maxWidth: _max_width + "px"
            };

            if (_browser_width >= _max_width) {
                _left = (_browser_width - _max_width) / 2;
            }

            if (_browser_height > 667) {
                _top = "7%";
                _height = "83%";
            }

            _style.left = _left + "px";
            _style.height = _height;
            _style.top = _top;
            return _style;
        },

        set_keyboard_height: function (kh) {
        },

        get_keyboard_height: function () {
            return _keyboard_height;
        },

        get_uuid: function () {
            return _get_uuid();
        },

        encode_utf8: function(s) {
            return unescape(encodeURIComponent(s));
        },

        page_size: function () {
            return _page_size;
        },

        device_online: function () {
            _device_online = true;
        },

        device_offline: function () {
            _device_online = false;
        },

        is_device_online: function () {
            return _device_online;
        },

        get_device_network: function () {
            return navigator.connection.type;
        },

        click_download: function (href, filename) {
            return _click_download(href, filename);
        },

        hide_statusbar: function (event) {
            if (ionic.Platform.isFullScreen) {
                $timeout(function () {
                    ionic.Platform.showStatusBar(false);
                });
            }
        },

        read_image_file: function (file, success, error) {
            _read_image_file(file, success, error);
        },

        is_file: function(item) {
            return angular.isObject(item) && item instanceof $window.File;
        },

        is_image_file: function(file) {
            if (!this.is_file(file)) {
                return false;
            }
            var type =  '|' + file.type.slice(file.type.lastIndexOf('/') + 1) + '|';
            return '|jpg|png|jpeg|bmp|gif|'.indexOf(type) !== -1;
        }
        
    };
}

ppmessageModule.factory('yvMime', [function () {
    
    /*
      .doc     application/msword
      .docx    application/vnd.openxmlformats-officedocument.wordprocessingml.document
      .rtf     application/rtf
      .xls     application/vnd.ms-excelapplication/x-excel
      .xlsx    application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
      .ppt     application/vnd.ms-powerpoint
      .pptx    application/vnd.openxmlformats-officedocument.presentationml.presentation
      .pps     application/vnd.ms-powerpoint
      .ppsx    application/vnd.openxmlformats-officedocument.presentationml.slideshow
      .pdf     application/pdf
      .swf     application/x-shockwave-flash
      .dll     application/x-msdownload
      .exe     application/octet-stream
      .msi     application/octet-stream
      .chm     application/octet-stream
      .cab     application/octet-stream
      .ocx     application/octet-stream
      .rar     application/octet-stream
      .tar     application/x-tar
      .tgz     application/x-compressed
      .zip     application/x-zip-compressed
      .z       application/x-compress
      .wav     audio/wav
      .wma     audio/x-ms-wma
      .wmv     video/x-ms-wmv
      .mp3 .mp2 .mpe .mpeg .mpg     audio/mpeg
      .rm      application/vnd.rn-realmedia
      .mid .midi .rmi     audio/mid
      .bmp     image/bmp
      .gif     image/gif
      .png     image/png
      .tif .tiff  image/tiff
      .jpe .jpeg .jpg     image/jpeg
      .txt      text/plain
      .xml      text/xml
      .html     text/html
      .css      text/css
      .js       text/javascript
      .mht .mhtml   message/rfc822
    */

    function _mime_icon(_mime) {
        var _word = "img/document-word.png",
            _xls = "img/document-xls.png",
            _pdf = "img/document-pdf.png",
            _ppt = "img/document-ppt.png",
            _plain = "img/document-plain.png",
            _map = {
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document": _word,
                "application/msword": _word,
                "application/vnd.ms-excel": _xls,
                "application/x-excel": _xls,
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": _xls,
                "application/vnd.ms-powerpoint": _ppt,
                "application/vnd.openxmlformats-officedocument.presentationml.presentation": _ppt,
                "application/vnd.openxmlformats-officedocument.presentationml.slideshow": _ppt,
                "application/pdf": _pdf
            };

        if (_map.hasOwnProperty(_mime)) {
            return _map[_mime];
        }

        return _plain;
    }

    function _mime_ext(_mime) {
        var _map = {
            "application/msword": "doc",
            "application/x-excel": "xls",
            "application/vnd.ms-excel": "xls",
            "application/vnd.ms-powerpoint": "ppt",

            "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
            "application/vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
            "application/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",

            "application/pdf": "pdf",

            "image/jpeg": "jpeg",
            "image/png": "png",
            "image/tiff": "tiff",
            "image/gif": "gif"
        };

        if (_map.hasOwnProperty(_mime)) {
            return _map[_mime];
        }

        return "bin";
    }

    return {
        mime_icon: function (_mime) {
            return _mime_icon(_mime);
        },

        mime_ext: function (_mime) {
            return _mime_ext(_mime);
        }

    };
}]);

ppmessageModule.factory("yvUploader", [
    "$timeout",
    "FileUploader",
    "yvLog",
    "yvAPI",
    "yvSys",
    "yvUser",
    "yvMain",
    "yvBase",
    "yvSend",
    "yvConstants",
function ($timeout, FileUploader, yvLog, yvAPI, yvSys, yvUser, yvMain, yvBase, yvSend, yvConstants) {

    function _get_raw_message(_file) {
        var _type = _file.type;
        var _subtype = null;
        var _pattern = new RegExp("^image/*");

        if (_pattern.test(_type)) {
            _subtype = yvConstants.MESSAGE_SUBTYPE.IMAGE;
        } else {
            _subtype = yvConstants.MESSAGE_SUBTYPE.FILE;
        }

        return {
            type: _subtype,
            data: {
                file: _file,
                size: _file.size,
                name: _file.name,
                mime: _file.type || "application/octet-stream"
            }
        };
    }


    // for pc only
    function _upload_file_in_pc(_msg, _item, success, error) {
        _item.onProgress = function (progress) {
            $timeout(function () {
                _msg.upload_progress = progress;
            });
        };
        _item.onSuccess = function (response) {
            success && success(response.fuuid);
        };
        _item.onCancel = function (response) {
            yvLog.log("file item upload canceled", _item);
        };
        _item.onError = function (err) {
            yvLog.error("file item upload error", err);
            error && error();
        };
        _msg.fileItem = _item;
        _msg.fileItem.upload();
    }

    function _on_after_adding(_item) {
        var _msg = null, _worker = null;
        var _file = _item._file;
        var _conv = yvBase.active("conversation");
        var _raw_message = _get_raw_message(_file);

        // if (_file.size > 1024 * 1024 * 20) {
        //     console.log("--------too big");
        //     return;
        // }        
        yvMain.prepare_send(_conv, _raw_message, function (_message) {
            _msg = _message;
            yvMain.update_message_status(_msg, yvConstants.SEND_STATUS.SEND_CHECKING);
            __not_existed();
            // the api of checking file repeatability is broken, so send directly.
            // _worker = new Worker('lib/sha1calculator.js');
            // _worker.onmessage = __on_message;
            // window.hash_file(_file, [_worker]);
        });


        function __error() {
            yvMain.update_message_status(_msg, yvConstants.SEND_STATUS.SEND_ERROR);
        }

        function __existed(_fid) {
            yvMain.update_message_status(_msg, yvConstants.SEND_STATUS.SEND_SENDING);
            yvMain.update_message_file(_msg, _fid);
            yvSend.send_message(_msg, false);
        }

        function __not_existed() {
            yvMain.update_message_status(_msg, yvConstants.SEND_STATUS.SEND_UPLOADING);
            _upload_file_in_pc(_msg, _item, __existed, __error);
        }

        function __check_existence(_sha1) {
            yvAPI.is_file_existed(_sha1, function (data) {
                if (data.existed) {
                    __existed(data.fid);
                } else {
                    __not_existed();
                }
            }, __error, __error);
        }

        function __on_message(event) {
            if (event.data.result) {
                _worker.terminate();
                __check_existence(event.data.result);
            }
        }

    }

    function _new_uploader() {
        //TO FIX BUG : can not select same file to upload
        //https://github.com/nervgh/angular-file-upload/wiki/FAQ
        FileUploader.FileSelect.prototype.isEmptyAfterSelection = function () {
            return true;
        };

        var _file_uploader = new FileUploader();
        _file_uploader.onAfterAddingFile = function (item) {
            _on_after_adding(item);
        };
        return _file_uploader;
    }

    return {
        get_uploader: function () {
            return _new_uploader();
        },

        send_file: function (file) {
            return _on_after_adding(file);
        }
    };
}]);

ppmessageModule.factory("yvLogin", [
    "$state",    
    "$timeout",
    "$ionicLoading",
    "yvSys",
    "yvAPI",
    "yvNav",
    "yvLog",
    "yvNoti",
    "yvUser",
    "yvMain",
    "yvLink",
    "yvAlert",
    "yvLogout",
    "yvConstants",
function ($state, $timeout, $ionicLoading, yvSys, yvAPI, yvNav, yvLog, yvNoti, yvUser, yvMain, yvLink, yvAlert, yvLogout, yvConstants) {

    var session = null;
    
    function LoginSession() {
        // user info for manual-login
        this.user_email = null;
        this.user_password = null;
        this.access_token = null;
        
        // make sure init one time
        if (typeof this.device_token !== "string") {
            // device info
            LoginSession.prototype.device_uuid = yvSys.get_device_uuid();
            LoginSession.prototype.device_model = yvSys.get_device_model();
            LoginSession.prototype.device_version = yvSys.get_device_version();
            LoginSession.prototype.device_platform = yvSys.get_device_platform();
            LoginSession.prototype.device_fullname = yvSys.get_device_fullname();
            
            LoginSession.prototype.login = function () {
                var self = this;
                yvAPI.token(self, function (response) {
                    yvAPI.login(self, function (response) {
                        self._login_success(response);
                    }, function () {
                        self._login_error("app.GLOBAL.ERR_NET");
                    }, function () {
                        self._login_error("app.GLOBAL.ERR_LOGIN");
                    });
                }, function () {
                    self._login_error("app.GLOBAL.ERR_NET");
                }, function () {
                    self._login_error("app.GLOBAL.ERR_USERPASS");
                });
            };

            LoginSession.prototype._login_error = function (error) {
                _stop_loading();
                yvAlert.tip(error);
            };
            
            LoginSession.prototype._login_success = function (data) {
                data.access_token = this.access_token;
                yvMain.add_login_user(data, _enter_app);
            };
        }
    };


    function _stop_loading() {
        $ionicLoading.hide();
    }

    
    function _start_loading() {
        $ionicLoading.show({
            delay: 100,
            duration: 150000,
            template: "<ion-spinner></ion-spinner>"
        });
    }

    
    function _api_error(res) {
        _stop_loading();
        yvNav.login_with_user();
        yvAlert.tip("app.GLOBAL.ERR_NET");
        console.error("api error, session invalid ?", res);
    }

    
    function _enter_app(offline) {
        yvNoti.init();
        yvMain.reload(offline, function () {
            $timeout(function () {
                yvNav.go_conversation_list();
                _stop_loading();
            });
        });
    }
    
    function _login_with_session(user) {
        if (!session) {
            session = new LoginSession();
        }
        session.user_email = user.email;
        session.access_token = user.access_token;
        session.device_uuid = user.device_uuid;

        // test api is actuall get_user_info with max timeout 10s.
        // if api failed because of token, then login with user.
        // if api failed because of network, enter app without network.
        // if api success, enter app with network.
        yvAPI.test_api(function (data) {
            if (data.mobile_device_uuid !== yvUser.get("device_uuid")) {
                // The user has logined in another device, we shall log lout now.
                yvLogout.local_logout();
            } else {
                yvUser.update_user_from_api(data);
                _enter_app();
            }
        }, function () {
            _enter_app(true);
        }, function () {
            yvNav.login_with_user();
        });
    }

    
    function _login(user) {
        var server = yvAPI.get_server();
        
        if (!session) {
            session = new LoginSession();
        }
        
        _start_loading();
        
        if (!user.user_email || !user.user_password) {
            session._login_error("app.GLOBAL.ERR_NO_ENOUGH_INFO");            
            return;
        }
   
        session.user_email = user.user_email;
        session.user_password = user.user_password;
        
        if (!server || server.id === -1) {
            session._login_error("app.GLOBAL.ERR_NO_SERVER");
            return;
        }

        session.device_uuid = yvSys.get_device_uuid(session.user_email);        
        session.login();
        return;
    }

    
    function _check_session() {
        session || yvLogout.logout_reset();
    }
    
    return {
        login: function (user) {
            return _login(user);
        },

        login_with_session: function (user) {
            return _login_with_session(user);
        },
        
        after_login: function () {
            return _after_login();
        },
        
        enter_app: function (offline) {
            return _enter_app(offline);
        },
        
        check_session: function () {
            return _check_session();
        },

        current_session: function () {
            return session;
        }
    };
}]);

ppmessageModule.factory("yvLogout", [
    "$rootScope",
    "yvDB",
    "yvSys",
    "yvNav",
    "yvAPI",
    "yvNoti",
    "yvBase",
function ($rootScope, yvDB, yvSys, yvNav, yvAPI, yvNoti, yvBase) {

    var scope = $rootScope.$new();

    scope.$on("event:logout", function (event) {
        _local_logout();
    });

    // If should_reset is true, next view is main-with-logo,
    // else it is noapp.login-with-user/noapp.login-no-user.
    function _local_logout(should_reset) {
        if (yvSys.has_db()) {
            yvDB.logout_user();
        }
        yvNoti.exit();
        yvBase.reset();
        yvNav.exit_app(should_reset);
    }


    function _logout() {
        yvAPI.logout();
        _local_logout(false);
    }

    return {
        logout: function () {
            _logout();
        },

        local_logout: function () {
            _local_logout(false);
        },

        logout_reset: function () {
            _local_logout(true);
        }
    };
}]);

ppmessageModule.factory('yvNav', [
    "$ionicHistory",
    "$timeout",
    "$state",
    "yvSys",
    "yvUser",
    "yvConstants",
function ($ionicHistory, $timeout, $state, yvSys, yvUser, yvConstants) {

    return {        
        go_back: function (_depth) {
            var historyId = $ionicHistory.currentHistoryId(),
            history = $ionicHistory.viewHistory().histories[historyId],
            targetViewIndex = history.stack.length - 1 - _depth;

            $ionicHistory.backView(history.stack[targetViewIndex]);
            $ionicHistory.goBack();
        },

        return_to: function (_name) {
            var historyId = $ionicHistory.currentHistoryId(),
            history = $ionicHistory.viewHistory().histories[historyId],
            i = history.stack.length - 1;

            for (i; i >= 0; i--) {
                if (history.stack[i].stateName === _name) {
                    $ionicHistory.backView(history.stack[i]);
                    $ionicHistory.goBack();
                }
            }
        },

        clear: function (cb) {
            $timeout(function () {
                $ionicHistory.clearHistory();
                $ionicHistory.clearCache().then(cb);
            });
        },

        disable_next: function () {
            $ionicHistory.nextViewOptions({
                disableAnimate: true,
                disableBack: true
            });
        },

        disable_back: function () {
            $ionicHistory.nextViewOptions({
                disableBack: true
            });
        },

        login_no_user: function () {
            this.disable_next();
            $state.go("noapp.login-no-user");
        },

        login_with_user: function (user) {
            this.disable_next();
            if (arguments.length === 0 || !user) {
                user = yvUser.get();
            }
            if (!user.email) {
                return this.login_no_user();
            }
            
            $state.go("noapp.login-with-user", {
                "icon": user.icon,
                "email": user.email,
                "fullname": user.fullname
            });
        },

        go_conversation_list: function () {
            this.disable_next();
            var state = "app.conversation-list";
            if (yvSys.in_mobile()) {
                state = "app.conversation-list-mobile";
            }
            $timeout(function () {
                $state.go(state);
            });
        },
        
        exit_app: function (should_reset) {
            this.disable_next();
            if (should_reset) {
                $state.go("main-with-logo");
                return;
            }
            this.login_with_user();
            return;
        }
    };

}]);

ppmessageModule.factory("yvLink", [
    "$window",
    "yvAPI",
    "yvSys",
    "yvUser",
    "yvMime",
    "yvFile",
    "yvLocal",
    "yvConstants",
function ($window, yvAPI, yvSys, yvUser, yvMime, yvFile, yvLocal, yvConstants) {

    return {
        default_user_icon: function () {
            return "img/default_user.png";
        },

        default_image_pic: function () {
            return "img/default_pic.png";
        },

        default_card_cover: function () {
            return "img/default_card_cover.png";
        },

        current_user_avatar: function () {
            var icon = yvUser.get("icon");
            return this.get_user_icon(icon);
        },
        
        get_user_icon: function (_icon) {
            if (_icon && _icon.indexOf("http") === 0) {
                return _icon;
            }
            
            var _img = null;
            if (_icon) {
                _img = yvAPI.get_icon_url(_icon);
            }
            
            if (_img === null) {
                _img = this.default_user_icon();
            }
            return _img;
        },

        get_real_icon: function (_icon, _cb) {
            if (!_icon) {
                return _cb(null);
            }
            return _cb(_icon);
        },
        
        get_message_image: function (_message) {
            if (_message.file instanceof $window.File) {
                return _message.file;
            }

            var file = _message.file || _message.thumbnail;

            if (!file) {
                return this.default_image_pic();                
            }            
            
            return yvAPI.get_image_url(file, yvMime.mime_ext(_message.mime));
        },

        open_link: function (event, cb) {
            // prevent opening link by default
            event.preventDefault();
            var href = event.target.href,
                options = "location=yes,closebuttoncaption=" + yvLocal.translate("app.GLOBAL.CLOSE");

            if (!href) {
                if (cb) { cb(); }
                return;
            }
            window.open(href, "_blank");
        }
    };
}]);

ppmessageModule.factory('yvLocal', [
    "$filter",
    "$translate",
    "yvSys",
    "yvAPI",
function ($filter, $translate, yvSys, yvAPI) {

    var _current_language = null;
    
    function _get_electron_session() {
        var win = require("electron").remote.getCurrentWindow();
        var session = win.webContents.session;
        return session;
    }
    
    // for Browser and Electron only
    function _get_current_language(callback) {
        var language = _current_language || navigator.language;
        callback && callback(language);
    }
    
    // for Browser and Electron only
    function _set_current_language(language) {
        _current_language = language;
    }

    function _translate(str) {
        if (str && typeof str === "string") {
            return $filter("translate")(str);
        }
        return str;
    }

    
    function _format_timestamp(timestamp, in_conversation) {
        if (!timestamp) {
            return "";
        }
        
        // Note: It should be noted that moments are mutable.
        // Calling any of the manipulation methods will change the original moment.
        var now = moment();
        var start = now.clone().startOf("day");
        var end = now.clone().endOf("day"); 
        var target = moment.unix(timestamp);

        // today
        if (target.isBetween(start, end)) {
            return target.format("HH:mm");
        }

        // future, should not happen, just in case
        if (target.isAfter(end)) {
            if (in_conversation) {
                return target.format("MM-DD");
            }
            return target.format("MM-DD HH:mm")
        }

        // yesterday
        start.subtract(1, "day");
        end.subtract(1, "day");
        if (target.isBetween(start, end)) {
            if (in_conversation) {
                return _translate("app.GLOBAL.YESTERDAY") + target.format(" HH:mm");
            }
            return _translate("app.GLOBAL.YESTERDAY");
        }
        
        // before yesterday, if in conversation, show date & time, if not, only show date
        if (in_conversation) {
            return target.format("MM-DD HH:mm");
        }
        return target.format("MM-DD");
    }

    
    function _set_moment_locale() {
        var locale = _translate("app.GLOBAL.TIMESTAMP_LANGUAGE");
        moment.locale(locale);
    }

    function _filter_language(language) {
        var lower = language.toLowerCase();
        if (lower.indexOf("zh") === 0) {
            return "zh-Hans";
        }
        if (lower.indexOf("en") === 0) {
            return "en";
        }
        return language;
    }
    
    return {
        localize: function (cb) {
            _get_current_language(function (current_language) {
                $translate.use(current_language).then(function () {
                    _set_moment_locale();
                    cb && cb();
                });
            });
        },
        
        localize_by_language: function (language) {
            $translate.use(language).then(function () {
                _set_moment_locale();
                _set_current_language(language);
            });
        },

        filter_language: function (language) {
            return _filter_language(language);
        },
        
        get_current_language: function (callback) {
            return _get_current_language(callback);
        },

        set_current_language: function (language) {
            return _set_current_language(language);
        },
        
        translate: function (_str) {
            return _translate(_str);
        },

        format_timestamp: function (timestamp, in_conversation) {
            return _format_timestamp(timestamp, in_conversation);
        }
    };
}]);

ppmessageModule.factory("FileChooser", [
    "$window",
function ($window) {

    function FileChooser() {
        // map files to dir-path
        this.filesMap = {};
    }

    // /storage/sdcard0/{""}
    FileChooser.ROOT_RELATIVE_PATH = "";

    FileChooser.prototype._errorHandler = function (e) {
        var msg = '',
            error = window.FileError;

        switch (e.code) {
        case error.QUOTA_EXCEEDED_ERR:
            msg = 'QUOTA_EXCEEDED_ERR';
            break;
        case error.NOT_FOUND_ERR:
            msg = 'NOT_FOUND_ERR';
            break;
        case error.SECURITY_ERR:
            msg = 'SECURITY_ERR';
            break;
        case error.INVALID_MODIFICATION_ERR:
            msg = 'INVALID_MODIFICATION_ERR';
            break;
        case error.INVALID_STATE_ERR:
            msg = 'INVALID_STATE_ERR';
            break;
        default:
            msg = 'Unknown Error' + e.code;
            break;
        }

        console.log('Error: ' + msg);
    };

    FileChooser.prototype._fillDirectorys = function (fileSystem, relativePath) {
        console.log('fill directorys : ' + relativePath);
        this.onBeforeFileClick(relativePath, true);

        if (this.filesMap[relativePath]) {
            console.log('[FileChooser]---->use Cache--->', relativePath);
            this.onDirectoryFilesLoadComplected(this.filesMap[relativePath]);
            return;
        }

        var that = this;

        fileSystem.root.getDirectory(relativePath, {create: false}, function (dirEntry) {

            function success(entries) {
                var fullPath = dirEntry.fullPath.slice(1, dirEntry.fullPath.length - 1),
                    root = (relativePath === "") ? true : false,
                    len = entries.length,
                    files = [],
                    i;

                fullPath = fullPath.indexOf('/') !== -1 ? dirEntry.fullPath + "../" : "";

                for (i = 0; i < len; i++) {
                    // ignore hidden entries
                    if (entries[i].name && entries[i].name.indexOf(".") == 0) continue;
                    files.push({
                        name: entries[i].name,
                        isDirectory: entries[i].isDirectory,
                        fullPath: entries[i].fullPath,
                        url: entries[i].toURL()
                    });
                }

                // sort entries by name
                files.sort(function (f1, f2) {
                    return f1.name < f2.name ? -1 : 1;
                });
                
                if (!root) {
                    files.unshift({
                        name: "..",
                        isDirectory: true,
                        fullPath: fullPath,
                        url: null
                    });
                }

                that.filesMap[relativePath] = { files: files, folder: dirEntry, root: root };
                that.onDirectoryFilesLoadComplected(that.filesMap[relativePath]);
            }

            function fail(error) {
                console("Failed to list directory contents: " + error.code);
                that.onDirectoryFilesLoadComplected([]);
            }

            var directoryReader = dirEntry.createReader();
            directoryReader.readEntries(success, fail);

        }, this._errorHandler);
    };

    /**
     * API: list directorys
     */
    FileChooser.prototype.fillDirectorys = function (relativePath) {
        if (this.fileSystem) {
            this._fillDirectorys(this.fileSystem, relativePath);
        } else {
            var that = this;

            $window.requestFileSystem = $window.requestFileSystem || $window.webkitRequestFileSystem;
            $window.requestFileSystem(LocalFileSystem.PERSISTENT, 1024 * 1024, function (fs) {
                that.fileSystem = fs;
                that._fillDirectorys(fs, relativePath);
            }, this._errorHandler);
        }

    };

    /**
     * API: readFile
     */
    FileChooser.prototype.getFile = function (fileRelativePath, successcallback, failcallback) {
        if (this.fileSystem) {
            this.fileSystem.root.getFile(fileRelativePath, {}, function (fileEntry) {

                fileEntry.file(function (file) {
                    if (successcallback) {
                        successcallback(file);
                    }
                });

            }, this._errorHandler);
        } else {
            failcallback('no filesystem');
        }
    };

    /**
     * API: Callback
     */
    FileChooser.prototype.onBeforeFileClick = function (filePath, isDirectory) {};

    /**
     * API: Callback
     */
    FileChooser.prototype.onDirectoryFilesLoadComplected = function (files) {};

    return FileChooser;
}]);

ppmessageModule.factory("yvDelegate", [
    "$ionicListDelegate",
    "$ionicScrollDelegate",
    "$ionicSideMenuDelegate",
function ($ionicListDelegate, $ionicScrollDelegate, $ionicSideMenuDelegate) {

    var SCROLL_HANDLE = "conversation-scroll";
    var SIDEMENU_HANDLE = "left-sidemenu";
    var LIST_HANDLE = "conversation-list";
    var delegateCache = {};

    function get_delegate(ionicDelegate, handle) {
        var delegate;
        if (delegateCache[handle]) {
            return delegateCache[handle];
        }
        delegate = ionicDelegate.$getByHandle(handle);
        delegateCache[handle] = delegate || null;
        return delegate;
    }

    return {

        get_scroll_delegate: function (handle) {
            if (arguments.length === 0 || !handle) {
                handle = SCROLL_HANDLE;
            }
            return get_delegate($ionicScrollDelegate, handle);
        },

        scroll_bottom: function (handle, shouldAnimate) {
            var delegate = this.get_scroll_delegate(handle);
            delegate && delegate.scrollBottom(!!shouldAnimate);
        },

        scroll_top: function (handle, shouldAnimate) {
            var delegate = this.get_scroll_delegate(handle);
            delegate && delegate.scrollTop(!!shouldAnimate);
        },
        
        scroll_resize: function (handle) {
            var delegate = this.get_scroll_delegate(handle);
            delegate && delegate.resize();
        },

        scroll_down: function (height, handle, shouldAnimate) {
            var delegate = this.get_scroll_delegate(handle);
            delegate && delegate.scrollBy(0, height, !!shouldAnimate);
        },
        
        get_sidemenu_delegate: function (handle) {
            if (arguments.length === 0 || !handle) {
                handle = SIDEMENU_HANDLE;
            }
            return get_delegate($ionicSideMenuDelegate, handle);
        },

        get_list_delegate: function (handle) {
            if (arguments.length === 0 || !handle) {
                handle = LIST_HANDLE;
            }
            return get_delegate($ionicListDelegate, handle);
        },
    };
}]);

ppmessageModule.factory("yvObject", [

function () {

    function PPObject(uuid) {
        this.uuid = uuid;
        
        if (typeof this.name !== "string") {
            PPObject.prototype.name = "";
            PPObject.prototype.icon = "";
            PPObject.prototype.email = "";
            PPObject.prototype.type = "DU";
            PPObject.prototype.updatetime = 0;
            PPObject.prototype.fullname = "";
            PPObject.prototype.signature = "";
            PPObject.prototype.need_update = false;

            // provide infos about portal user
            PPObject.prototype.mobile_online = false;
            PPObject.prototype.browser_online = false;
            PPObject.prototype.extra_data = null;            
        }
    }

    return {
        check_prototype: function (object) {
            return PPObject.prototype.isPrototypeOf(object);
        },

        create: function (uuid) {
            var object = new PPObject(uuid);
            return object;
        }
    }

}]);

ppmessageModule.factory("yvContact", [

function () {

    function Contact(uuid) {
        this.uuid = uuid;

        if (typeof this.name !== "string") {
            Contact.prototype.name = "";
            Contact.prototype.icon = "";
            Contact.prototype.email = "";
            Contact.prototype.fullname = "";
            Contact.prototype.signature = "";
            Contact.prototype.is_portal_user = false;
            Contact.prototype.is_service_user = true;

            Contact.prototype.online = false;
            Contact.prototype.active = false;
        }
    }

    return {
        check_prototype: function (contact) {
            return Contact.prototype.isPrototypeOf(contact);
        },

        create: function (uuid) {
            var contact = new Contact(uuid);
            return contact;
        }
    }
}]);

ppmessageModule.factory("yvConversation", [
    "$rootScope",
function ($rootScope) {

    function Conversation(uuid) {
        this.uuid = uuid;
        this.messages = [];
        
        if (typeof this.type !== "string") {
            Conversation.prototype.type = "";
            Conversation.prototype.name = "";
            Conversation.prototype.icon = "";
            Conversation.prototype.unread = 0;
            Conversation.prototype.user_uuid = "";
            Conversation.prototype.group_uuid = "";
            Conversation.prototype.assigned_uuid = "";
            Conversation.prototype.last_chat_text = "";
            Conversation.prototype.latest_message = null;
            Conversation.prototype.need_update = false;
            Conversation.prototype.active = false;
            Conversation.prototype.show = true;            
            
            Conversation.prototype.has_message = function (message) {
                if (this.messages.indexOf(message) != -1) {
                    return true;
                }
                var target = this.get_message_by_tid(message.task_uuid); 
                return target ? true : false;
            };

            Conversation.prototype.get_message_by_tid = function (task_uuid) {
                for (var i = 0, length = this.messages.length; i < length; i++) {
                    if (this.messages[i].task_uuid == task_uuid) {
                        return this.messages[i];
                    }
                }
                return null;
            };

            Conversation.prototype.add_message = function (message) {
                if (this.has_message(message)) {
                    return; // dont repeatly add message
                }
                this.messages.push(message);
                this._refresh();
            };

            Conversation.prototype.delete_message = function (message) {
                var index = this.messages.indexOf(message);
                if (index !== -1) {
                    this.messages.splice(index, 1);
                    this._refresh();
                }
            };

            Conversation.prototype._reorder_messages = function () {
                var length = this.messages.length;
                this.messages.sort(_sort_message_by_timestamp);
                return this.messages[length - 1] || null;
            };

            Conversation.prototype._refresh = function () {
                this.latest_message = this._reorder_messages();
                _reorder_conversations();
            };
        }


        function _sort_message_by_timestamp(message1, message2) {
            return message1.timestamp - message2.timestamp;
        }


        function _reorder_conversations() {
            $rootScope.$broadcast("event:reorder-conversations");
        }
        
    }

    
    return {
        check_prototype: function (conversation) {
            return Conversation.prototype.isPrototypeOf(conversation);
        },

        create: function (conv_uuid) {
            var conversation = new Conversation(conv_uuid);
            return conversation;
        }
    }
}]);

ppmessageModule.factory('yvBase', [
    "$timeout",
    "$rootScope",
    "yvDB",
    "yvSys",
    "yvAPI",
    "yvLog",
    "yvLink",
    "yvObject",
    "yvMessage",
    "yvContact",
    "yvConversation",
function ($timeout, $rootScope, yvDB, yvSys, yvAPI, yvLog, yvLink, yvObject, yvMessage, yvContact, yvConversation) {
    
    var scope = $rootScope.$new();
    var service_mapping = null;
    var update_mapping = null;
    var scope_mapping = null;
    
    scope.objects = {
        dict: {},
        list: []
    };
    
    scope.conversations = {
        dict: {},
        list: [],
        page: 0,
        current_active: null
    };

    scope.contacts = {
        dict: {},
        list: [],
        current_active: null
    };

    scope_mapping = {
        "object": scope.objects,
        "contact": scope.contacts,
        "conversation": scope.conversations
    };
    
    service_mapping = {
        "object": yvObject,
        "contact": yvContact,
        "conversation": yvConversation
    };

    update_mapping = {
        "object": _update_object,
        "conversation": _update_conversation
    };
    
    scope.$watchCollection("conversations.dict", function (new_dict, old_dict) {
        _regenerate_conversations_list(new_dict);
        _check_update_conversations(new_dict);
    });
    
    scope.$watchCollection("contacts.dict", function (new_dict, old_dict) {
        _regenerate_contacts_list(new_dict);
    });

    scope.$watchCollection("objects.dict", function (new_objects, old_objects) {
        _check_update_objects(new_objects);
    });
    
    scope.$on("event:reset-base", function () {
        _reset();
    });
    
    scope.$on("event:reorder-conversations", function () {
        _reorder_conversations();
    });

    
    function _reorder_conversations() {
        scope.conversations.list.sort(function (conv1, conv2) {
            if (!conv1.latest_message && !conv2.latest_message) {
                return conv2.$$hashKey < conv1.$$hashKey ? 1 : -1;
            }
            if (!conv1.latest_message && conv2.latest_message) {
                return 1;
            }
            if (conv1.latest_message && !conv2.latest_message) {
                return -1;
            }
            return conv2.latest_message.timestamp - conv1.latest_message.timestamp;
        });
    }

    
    function _reorder_contacts() {
        scope.contacts.list.sort(function (contact1, contact2) {
            if (contact1.fullname <= contact2.fullname) {
                return 1;
            }
            return -1;
        });
    }


    function _regenerate_conversations_list(new_dict) {
        scope.conversations.list.length = 0;
        angular.forEach(new_dict, function (conv) {
            scope.conversations.list.push(conv);
        });
        _reorder_conversations();
    }


    function _regenerate_contacts_list(new_dict) {
        scope.contacts.list.length = 0;
        angular.forEach(new_dict, function (contact) {
            scope.contacts.list.push(contact);
        });
        _reorder_contacts();
    }


    function _check_update_objects(new_objects) {
        angular.forEach(new_objects, function (object, uuid) {
            if (!object.need_update) {
                return;
            }

            object.need_update = false;
            yvAPI.get_user_info(uuid, function (data) {
                _update_object(object, data);
            }, function () {
                object.need_update = true;
            }, function () {
                object.need_update = true;
            });
        });
    }
    

    function _update_object(object, data, callback) {
        object.name = data.user_name;
        object.email = data.user_email;
        object.updatetime = data.updatetime;
        object.fullname = data.user_fullname;
        object.signature = data.user_signature;

        yvLink.get_real_icon(data.user_icon, function (icon) {
            $timeout(function () {
                object.icon = icon;
            });
            callback && callback(object);
            
            if (yvSys.has_db()) {
                yvDB.add_object(object);
            }
        });
    }


    function _check_update_conversations(new_conversations) {
        angular.forEach(new_conversations, function (conversation, uuid) {
            if (!conversation.need_update) {
                return;
            }

            conversation.need_update = false;
            yvAPI.get_conversation(uuid, function (data) {
                if (data.user_uuid && !scope.objects.dict[data.user_uuid]) {
                    var new_object = yvObject.create(data.user_uuid);
                    new_object.need_update = true;
                    scope.objects.dict[data.user_uuid] = new_object;
                }
                conversation.show = true;
                _update_conversation(conversation, data);
            }, function () {
                conversation.need_update = true;
            }, function () {
                conversation.need_update = true;
            });
        });
    }
    

    function _update_conversation(conversation, conv, callback) {
        var icon = conv.conversation_icon;
        var name = conv.conversation_name;

        if (conv.conversation_data && conv.conversation_data.conversation_icon) {
            icon = conv.conversation_data.conversation_icon;
        }
        if (conv.conversation_data && conv.conversation_data.conversation_name) {
            name = conv.conversation_data.conversation_name;
        }
        if (conv.latest_message) {
            conversation.latest_message = yvMessage.history_message(conv.latest_message);
        }

        conversation.name = name;
        conversation.user_uuid = conv.user_uuid;
        conversation.group_uuid = conv.group_uuid;
        conversation.type = conv.conversation_type;        

        _reorder_conversations();
        callback && callback(conversation);

        yvLink.get_real_icon(icon, function (real_icon) {
            $timeout(function () {
                conversation.icon = real_icon;
            });
            
            if (yvSys.has_db()) {
                yvDB.add_conversation(conversation);
            }
        });
    }

    
    function _reset() {
        scope.objects.dict = {};
        scope.contacts.dict = {};
        scope.conversations.dict = {};
    }

    
    function _new(type, uuid) {
        var service = service_mapping[type];
        if (service) {
            return service.create(uuid);
        }
        return null;
    }

    function _prototype(type, item) {
        var service = service_mapping[type];
        if (service) {
            return service.check_prototype(item);
        }
        return false;
    }
    
    return {
        reset: function () {
            _reset();
        },

        get: function (type, uuid, attribute) {
            var hash = scope_mapping[type];
            if (hash && hash.dict.hasOwnProperty(uuid)) {
                var item = hash.dict[uuid];
                if (arguments.length === 2) {
                    return item;
                }
                if (item.hasOwnProperty(attribute)) {
                    return item[attribute];
                }
            }
            return null;
        },
        
        get_scope: function (type) {
            var hash = scope_mapping[type];
            return hash ? hash : null;
        },

        get_list: function (type) {
            var hash = scope_mapping[type];
            return hash ? hash.list : null;
        },

        set: function (type, uuid, key, value) {
            var data = {};
            data[key] = value;
            this.mset(type, uuid, data);
        },

        mset: function (type, uuid, data) {
            var hash = scope_mapping[type];
            if (!hash) {
                return;
            }
            var item = hash.dict[uuid];
            if (!item) {
                item = _new(type, uuid);
                hash.dict[uuid] = item;
            }
            angular.forEach(data, function (value, key) {
                item[key] = value;
            });
        },
        
        active: function (type, itemOrUuid) {
            var hash = scope_mapping[type];
            if (!hash) {
                return null;
            }
            if (arguments.length === 1) {
                return hash.current_active;
            }

            var target = null;
            var current = hash.current_active;            

            if (_prototype(type, itemOrUuid) || !itemOrUuid) {
                target = itemOrUuid;
            } else if (hash.dict.hasOwnProperty(itemOrUuid)) {
                target = hash.dict[itemOrUuid];
            }

            if (current) current.active = false;
            if (target) target.active = true;
            hash.current_active = target;

            return hash.current_active;
        },

        remove: function (type, uuid) {
            var hash = scope_mapping[type];
            if (!hash) {
                return;
            }
            var item = hash.dict[uuid];
            item && delete hash.dict[uuid];
        },

        create: function (type, uuid) {
            var item = this.get(type, uuid);
            return item ? item : _new(type, uuid);
        },

        add: function (type, item) {
            var hash = scope_mapping[type];
            if (hash.dict[item.uuid]) {
                return;
            }
            if (_prototype(type, item)) {
                hash.dict[item.uuid] = item;
            }
        },
        
        update: function (type, instance, data, callback) {
            var update = update_mapping[type];
            update && update(instance, data, callback);
        },
        
    };
}]);

ppmessageModule.factory("yvMain", [
    "$q",
    "$timeout",
    "$rootScope",
    "yvDB",
    "yvLog",
    "yvSys",
    "yvAPI",
    "yvNav",
    "yvNoti",
    "yvMime",
    "yvSend",
    "yvUser",
    "yvLink",
    "yvFile",
    "yvType",
    "yvBase",
    "yvLogout",
    "yvMessage",
    "yvConstants",
function ($q, $timeout, $rootScope, yvDB, yvLog, yvSys, yvAPI, yvNav, yvNoti, yvMime, yvSend, yvUser, yvLink, yvFile, yvType, yvBase, yvLogout,
          yvMessage, yvConstants) {

    var scope = $rootScope.$new();

    scope.$on("event:add_message", function(event, message) {
        _add_message(message, true, null);
    });

    scope.$on("event:receive_ack_message", function(event, message) {
        _receive_ack_message(message);
    });
    
    scope.$on("event:update_message_all", function(event, message, params) {
        _update_message_all(message, params);
    });

    scope.$on("event:update_message_status", function(event, message, status) {
        _update_message_status(message, status);
    });

    scope.$on("event:add-service-user", function(event) {
        _update_contacts_from_server();
    });
    
    function _init_yvdb(callback) {
        if (yvSys.has_db()) {
            return yvDB.init_yvdb(callback);
        }
        _set_server();
        callback && callback(null);
    }


    function _init_userdb(uuid, callback) {
        if (yvSys.has_db()) {
            return yvDB.init_userdb(uuid, callback);
        }
        callback && callback();
    }


    function _add_login_user(data, callback) {
        var user = yvUser.update_user_from_login(data);
        
        yvLink.get_real_icon(user.icon, function (icon) {
            user.icon = icon;
            yvBase.mset("object", user.uuid, {
                name: user.name,
                icon: user.icon,
                email: user.email,
                fullname: user.fullname,
                signature: user.signature,
                updatetime: user.updatetime
            });
            
            if (!yvSys.has_db()) {
                callback && callback();
                return;
            }

            yvDB.add_login_user(user, data.app, function () {
                yvDB.init_userdb(user.uuid, function () {
                    yvDB.add_object(user);
                    callback && callback();
                });
            });
        });
    }


    function _set_server() {
        if (yvSys.has_db()) {
            return yvDB.query_server();
        }
        var server = {
            id: 0,
            name: "web",
            host: window.location.hostname,
            port: window.location.port,
            protocol: window.location.protocol + "//"
        };
        yvAPI.set_server(server);
    }


    function _unread_zero(conversation) {
        conversation.unread = 0;
        if (yvSys.has_db()) {
            yvDB.unread_zero(conversation.uuid);
        }
    }


    function _delete_message(conversation, message) {
        conversation.delete_message(message);
        if (yvSys.has_db()) {
            yvDB.delete_message(message);
        }
    }


    function _delete_conversation(conversation) {
        yvBase.remove("conversation", conversation.uuid);

        if (yvSys.has_db()) {
            yvDB.delete_conversation(conversation);
        }
    }

    function _delete_all_conversations(callback) {
        yvBase.get_scope("conversation").page = 0;
        yvBase.get_scope("conversation").dict = {};

        if (yvSys.has_db()) {
            yvDB.delete_all_conversations(callback);
        } else {
            callback && callback();
        }
    }

    function _delete_all_contacts(callback) {
        yvBase.get_scope("contact").dict = {};

        if (yvSys.has_db()) {
            yvDB.delete_all_contacts(callback);
        } else {
            callback && callback();
        }
    }

    // key can be 'icon', 'fullname', 'signature'
    function _update_current_user(key, value) {
        if (["icon", "fullname", "signature"].indexOf(key) === -1) {
            return;
        }

        yvUser.set(key, value);
        yvBase.set("object", yvUser.get("uuid"), key, value);

        if (yvSys.has_db()) {
            yvDB.update_current_user(key, value);
        }
    }


    function _update_noti_settings(key, value) {
        if (["show_badge", "mute_notification", "silence_notification"].indexOf(key) === -1) {
            return;
        }

        yvUser.set(key, value);
        
        if (yvSys.has_db()) {
            yvDB.update_noti_settings(key, value);
        } 
    }

    function _add_object(object, callback) {
        if (!object) {
            return;
        }

        var local_object = yvBase.get("object", object.uuid);
        if (local_object && local_object.updatetime >= parseInt(object.updatetime)) {
            callback && callback(local_object);
            return;
        }

        var ppobject = yvBase.create("object", object.uuid);
        yvBase.add("object", ppobject);
        yvBase.update("object", ppobject, object, function (obj) {
            callback && callback(obj);
        });
    }


    function _check_object(uuid) {
        var object = yvBase.get("object", uuid);
        console.log("check object: %o, by uuid: %s.", object, uuid);
        object || yvBase.set("object", uuid, "need_update", true);
    }


    function _add_contact(contact) {
        yvBase.mset("contact", contact.uuid, {
            name: contact.user_name,
            email: contact.user_email,
            fullname: contact.user_fullname,
            signature: contact.user_signature,
            is_portal_user: !!contact.is_portal_user,
            is_service_user: !!contact.is_service_user
        });

        _add_object(contact, function (object) {
            yvBase.set("contact", contact.uuid, "icon", object.icon);
        });

        if (yvSys.has_db()) {
            yvDB.add_contact(contact);
        }
    }


    function _is_conversation_online (conversation) {
        switch (conversation.type) {
        case yvConstants.CONVERSATION_TYPE.S2S:
            return true;
        case yvConstants.CONVERSATION_TYPE.P2S:
            var portal_user = yvBase.get("object", conversation.user_uuid);
            if (!portal_user) return false;
            if (portal_user.mobile_online || portal_user.browser_online) return true;
        default:
            return false;
        }
    }


    function _add_conversation(conv, callback) {
        var conversation = yvBase.create("conversation", conv.uuid);
        yvBase.add("conversation", conversation);
        yvBase.update("conversation", conversation, conv, callback);
    }


    // Called when chat with contact. open real conversation if conversation_name matchs a local conversation.
    function _open_conversation(params, callback) {
        var conv_list = yvBase.get_list("conversation"), conv = null;

        for (var i in conv_list) {
            conv = conv_list[i];
            if (conv.type === params.conversation_type && conv.name === params.conversation_name) {
                yvBase.active("conversation", conv);
                callback && callback(conv);
                return;
            }
        }

        params.user_uuid = yvUser.get("uuid");
        yvAPI.request("/PPKEFU_CREATE_CONVERSATION", params, function (data) {
            _add_conversation(data, function (conversation) {
                yvBase.active("conversation", conversation);
                callback && callback(conversation);
            });
        });
    }


    function _add_message_to_conversation(conversation, message, callback) {
        var active = yvBase.active("conversation");
        if (!active || (active.uuid != conversation.uuid && message.direction === yvConstants.MESSAGE_DIR.DIR_IN)) {
            conversation.unread += 1;
        }
        if (conversation.latest_message && conversation.latest_message.timestamp > message.timestamp) {
            message.timestamp = conversation.latest_message.timestamp + 1;
        }
        conversation.add_message(message);
        callback && callback();

        if (yvSys.has_db()) {
            yvDB.insert_message(message);
            yvDB.update_conversation_unread(conversation);
        }
    }

    function _update_conversation(message, callback) {
        if (!message) {
            callback && callback();
            return;
        }

        var conversation = yvBase.get("conversation", message.conversation_uuid);
        if (conversation) {
            _add_message_to_conversation(conversation, message, callback);
            return;
        }

        conversation = yvBase.create("conversation", message.conversation_uuid);
        conversation.need_update = true;
        conversation.show = false;
        yvBase.add("conversation", conversation);
        _add_message_to_conversation(conversation, message, callback);
    }



    function _download_message_file(message, cb) {
        var _ext = null, _url = null, _body = null;

        if (yvType.is_text(message)) {
            return cb(message);
        }

        if (yvType.is_image(message)) {
            _body = angular.fromJson(message.body);
            message.mime = _body.mime;
            message.thumbnail = _body.thum;
            message.file = _body.orig;
            return cb(message);
        }

        if (yvType.is_file(message)) {
            _body = angular.fromJson(message.body);
            message.mime = _body.mime;
            message.name = _body.name;
            message.size = _body.size;
            message.file = _body.fid;
            return cb(message);
        }

        console.error("download message file can't handle message --> %o", message);
    }


    function _receive_ack_message(message) {
        if (!message || message.code == 0) {
            return;
        }
        yvLog.error("receive ack message error", message.reason, message);
        var conversation = yvBase.get("conversation", message.extra.conversation_uuid);
        if (conversation) { 
            var target = conversation.get_message_by_tid(message.extra.uuid);
            target && _update_message_status(target, yvConstants.SEND_STATUS.SEND_ERROR);
        }
    }

    
    function _ack_message(_message, _success, _error) {
        var list = [_message.push_uuid];
        _ack_message_list(list, _success, _error);
    }


    function _ack_message_list(_uuid_list, _success, _error) {
        var _ack_param = {"list": _uuid_list};
        yvAPI.ack_message(_ack_param, _success, _error, _error);
    }


    function _check_logout(_message, _cb) {
        var _device_uuid = yvUser.get("device_uuid");
        if (_message.body === _device_uuid) {
            yvLogout.local_logout();
        }
        _cb && _cb();
    }


    function _handle_message(message) {
        _download_message_file(message, function (msg) {
            _update_conversation(msg);
        });
    }


    //incoming message
    function _add_message(raw_message, with_ack) {
        var message = yvMessage.get_standard_message(raw_message);

        if (yvType.is_logout(message)) {
            with_ack && _check_logout(message);
            return;
        }

        if (!message.conversation_uuid) {
            with_ack && _ack_message(message);
            return;
        }

        _handle_message(message);
        with_ack && _ack_message(message);
        message.from_user ? _add_object(message.from_user) : _check_object(message.from_uuid);
    }


    function _load_conversation_messages(conversation, callback) {
        if (!yvSys.has_db()) {
            callback && callback(0);
            return;
        }

        yvDB.query_messages(conversation.uuid, function (res) {
            var item = null, message = null;
            for (var i = 0, len = res.rows.length; i < len; i++) {
                item = res.rows.item(i);
                message = yvMessage.create(item.task_uuid);
                message.id = item.id;
                angular.forEach(item, function (value, key) {
                    message[key] = value;
                });
                conversation.messages.push(message);
            }
            conversation._refresh();
            callback && callback(len);
        });
    }


    function _update_message_all(message, params) {
        $timeout(function () {
            message.status = params.status;
            message.timestamp = params.timestamp;
            message.task_uuid = params.task_uuid;
        });

        yvSys.has_db() && yvDB.update_message_status(message);
    }


    function _update_message_status(message, status) {
        $timeout(function () {
            message.status = status;
        });
        yvSys.has_db() && yvDB.update_message_status(message);
    }


    function _update_message_file(message, file) {
        // Note: do not use $timeout
        message.file = file;
        yvSys.has_db() && yvDB.update_message_file(message);
    }


    // Upload file for message in native iOS and Android.
    // Message with a valid message_mime will be uploaded, or it will be directly sended.
    // All message in PC and mobile chrome, file message in Android, will be uploaded by other way.
    function _upload_message_file(_message, _cb) {
        _cb && _cb(_message);
    }


    // save message to local storage before send it to server, including 2 steps:
    // 1. insert and display message in this conversation
    // 2. update latest message of this converstion
    function _prepare_send(conversation, raw_message, callback) {
        var message = yvMessage.create_sending_message(conversation, raw_message);
        conversation.add_message(message);
        callback && callback(message);

        if (yvSys.has_db()) {
            yvDB.insert_message(message);
        }
    }


    function _send_message(conversation, raw_message, callback) {
        _prepare_send(conversation, raw_message, function (message) {
            var _upload_message = typeof callback === "function" ? callback : _upload_message_file;
            _upload_message(message, function (msg) {
                yvSend.send_message(msg, false);
            });
        });
    }


    function _forward_message_new(_forward, _cb) {
        var _m = yvMessage.create_forward_message(_forward);

        _prepare_send(_m, function (_message) {
            yvSend.send_message(_message, true);
        });
    }


    function _update_contacts_from_server() {
        var defer = $q.defer();

        function __error() {
            defer.reject("error in update contacts from server");
        }

        yvAPI.get_service_user_list(function (data) {
            console.log("updating contacts from server..., total count: %d.", data.list.length);
            _delete_all_contacts(function () {
                angular.forEach(data.list, function (user) {
                    _add_contact(user);
                });
                defer.resolve("finish update contacts from server");
            });
        }, __error, __error);

        return defer.promise;
    }


    function _reorder_conversations(conv1, conv2) {
        if (conv1.latest_message && !conv2.latest_message) {
            return -1;
        }
        if (!conv1.latest_message && conv2.latest_message) {
            return 1;
        }
        if (!conv1.latest_message && !conv2.latest_message) {
            var upt1 = yvMessage.string_to_ts(conv1.updatetime);
            var upt2 = yvMessage.string_to_ts(conv2.updatetime);
            return upt2 - upt1;
        }
        var t1 = yvMessage.string_to_ts(conv1.latest_message.createtime);
        var t2 = yvMessage.string_to_ts(conv2.latest_message.createtime);
        return t2 - t1;
    }


    function _add_conversation_from_api_reserve(list) {
        var user_set = {};
        angular.forEach(list, function (conv) {
            if (yvBase.get("conversation", conv.uuid) || !conv.latest_message) {
                return; // reserve is old or no latest message, ignore it
            }
            _add_conversation(conv, null);
            user_set[conv.user_uuid] = conv.from_user;
        });
        angular.forEach(user_set, function (user) {
            _add_object(user);
        });
    }


    function _update_conversations_from_server() {
        var defer = $q.defer();
        var args = { "page_offset": 0, "page_size": yvSys.page_size() };

        function __error() {
            defer.reject("error in update conversations from server");
        }

        yvAPI.get_conversation_page(args, function (data) {
            console.log("updating conversations from server..., total count: %d.", data.list.length, data.list);
            _delete_all_conversations(function () {
                _add_conversation_from_api_reserve(data.list);
                defer.resolve("finish update conversations from server");
            });
        }, __error, __error);

        return defer.promise;
    }

    function _load_objects_from_database() {
        var _defer = $q.defer();

        yvDB.load_objects(function (tx, res) {
            var item = null;

            for (var i = 0, len = res.rows.length; i < len; i++) {
                item = res.rows.item(i);
                yvBase.mset("object", item.uuid, item);
            }
            _defer.resolve("finish load objects");
        }, function (tx, error) {
            _defer.reject("error in load objects");
        });

        return _defer.promise;
    }


    function _load_conversations_from_database() {
        var _defer = $q.defer();

        yvDB.load_conversations(function (tx, res) {
            var item = null;
            for (var i = 0, len = res.rows.length; i < len; i++) {
                item = res.rows.item(i);
                yvDB.get_latest_message(item, function (message, conv) {
                    conv.latest_message = message;
                    yvBase.mset("conversation", conv.uuid, conv);
                });
            }
            _defer.resolve("finish load conversations");
        }, function (tx, error) {
            _defer.reject("error in load conversations");
        });

        return _defer.promise;
    }


    function _load_contacts_from_database() {
        var _defer = $q.defer();

        yvDB.load_contacts(function (tx, res) {
            var item = null;

            for (var i = 0, len = res.rows.length; i < len; i++) {
                item = res.rows.item(i);
                item.is_portal_user = !!item.is_portal_user;
                item.is_service_user = !!item.is_service_user;
                yvBase.mset("contact", item.uuid, item);
            }
            _defer.resolve("finish load contacts");
        }, function (tx, error) {
            _defer.reject("error in load contacts");
        });

        return _defer.promise;
    }


    function _update_all_from_server(success, error) {
        var p0 = _update_contacts_from_server();
        var p1 = _update_conversations_from_server();

        yvBase.reset();

        $q.all([p0, p1]).then(function (value) {
            success && success();
        }, function (reason) {
            yvLog.log("update all from server error:", reason);
            error && error();
        });
    }


    function _load_all_from_database(cb) {
        var p0 = _load_objects_from_database();
        var p1 = _load_contacts_from_database();
        var p2 = _load_conversations_from_database();

        yvBase.reset();
        
        $q.all([p0, p1, p2]).finally(function () {
            cb && cb();
        });
    }


    function _reload(callback) {
        _update_all_from_server(function () {
            callback && callback();
        }, function () {
            _offline_reload(callback);
        });
    }

    function _offline_reload(callback) {
        if (yvSys.has_db()) {
            _load_all_from_database(function () {
                callback && callback();
            });
        }
    }
    

    return {
        init_yvdb: function (callback) {
            _init_yvdb(callback);
        },

        init_userdb: function (uuid, callback) {
            _init_userdb(uuid, callback);
        },

        add_login_user: function (userdata, callback) {
            _add_login_user(userdata, callback);
        },

        set_server: function () {
            _set_server();
        },

        unread_zero: function (conversation) {
            _unread_zero(conversation);
        },

        delete_message: function (conversation, message) {
            _delete_message(conversation, message);
        },

        delete_conversation: function (conversation) {
            _delete_conversation(conversation);
        },

        update_conversations_from_server: function () {
            return _update_conversations_from_server();
        },

        reload: function (offline, callback) {
            if (!!offline) {
                _offline_reload(callback);
            } else {
                _reload(callback);
            }
        },
        
        open_conversation: function (params, callback) {
            _open_conversation(params, callback);
        },

        is_conversation_online: function (conversation) {
            return _is_conversation_online(conversation);
        },
        
        add_conversation_from_api_reserve: function (list, callback) {
            _add_conversation_from_api_reserve(list, callback);
        },

        add_message: function (message, with_ack, callback) {
            _add_message(message, with_ack, callback);
        },

        prepare_send: function (conversation, raw_message, callback) {
            _prepare_send(conversation, raw_message, callback);
        },
        
        send_message: function (conversation, raw_message, callback) {
            _send_message(conversation, raw_message, callback);
        },

        load_conversation_messages: function (conversation, callback) {
            _load_conversation_messages(conversation, callback);
        },

        update_message_status: function (message, status) {
            _update_message_status(message, status);
        },

        update_message_file: function (message, file) {
            _update_message_file(message, file);
        },

        update_message_all: function (message, params) {
            _update_message_all(message, params);
        },

        update_current_user: function (key, value) {
            _update_current_user(key, value);
        },

        update_noti_settings: function (key, value) {
            _update_noti_settings(key, value);
        }

    };

}]);

ppmessageModule.factory("yvTest", [
    "yvAPI",
    "yvSys",
    "yvUser",
    "yvLog",
function (yvAPI, yvSys, yvUser, yvLog) {
    
    function test_api_validate_online_device() {
        yvAPI.validate_online_device(function(res) {
            yvLog.green("success", res);
        }, function (err) {
            yvLog.red("error", err);
        }, function (res) {
            yvLog.yellow("api error", res)
        });
    }
    
    

    return {
        api_validate_online_device: function () {
            test_api_validate_online_device();
        }
    };
    
}]);

ppmessageModule.factory("yvMonitor", [
    "yvBase",
    "yvMain",
    "yvTest",
function (yvBase, yvMain, yvTest) {
    var monitor = {
        "yvBase": yvBase,
        "yvMain": yvMain,
        "yvTest": yvTest
    };
    
    return monitor;
}]);

ppmessageModule.factory("yvMenu", [
    "yvLog",
    "yvSys",
function (yvLog, yvSys) {

    function getMenuTemplate() {
        var template = [
            {
                label: 'Edit',
                submenu: [
                    {
                        label: 'Undo',
                        accelerator: 'CmdOrCtrl+Z',
                        role: 'undo'
                    },
                    {
                        label: 'Redo',
                        accelerator: 'Shift+CmdOrCtrl+Z',
                        role: 'redo'
                    },
                    {
                        type: 'separator'
                    },
                    {
                        label: 'Cut',
                        accelerator: 'CmdOrCtrl+X',
                        role: 'cut'
                    },
                    {
                        label: 'Copy',
                        accelerator: 'CmdOrCtrl+C',
                        role: 'copy'
                    },
                    {
                        label: 'Paste',
                        accelerator: 'CmdOrCtrl+V',
                        role: 'paste'
                    },
                    {
                        label: 'Select All',
                        accelerator: 'CmdOrCtrl+A',
                        role: 'selectall'
                    },
                ]
            },
            {
                label: 'View',
                submenu: [
                    {
                        label: 'Reload',
                        accelerator: 'CmdOrCtrl+R',
                        click: function(item, focusedWindow) {
                            if (focusedWindow)
                                focusedWindow.reload();
                        }
                    },
                    {
                        label: 'Toggle Full Screen',
                        accelerator: (function() {
                            if (process.platform == 'darwin')
                                return 'Ctrl+Command+F';
                            else
                                return 'F11';
                        })(),
                        click: function(item, focusedWindow) {
                            if (focusedWindow)
                                focusedWindow.setFullScreen(!focusedWindow.isFullScreen());
                        }
                    },
                    // {
                    //     label: 'Toggle Developer Tools',
                    //     accelerator: (function() {
                    //         if (process.platform == 'darwin')
                    //             return 'Alt+Command+I';
                    //         else
                    //             return 'Ctrl+Shift+I';
                    //     })(),
                    //     click: function(item, focusedWindow) {
                    //         if (focusedWindow)
                    //             focusedWindow.toggleDevTools();
                    //     }
                    // },
                ]
            },
            {
                label: 'Window',
                role: 'window',
                submenu: [
                    {
                        label: 'Minimize',
                        accelerator: 'CmdOrCtrl+M',
                        role: 'minimize'
                    },
                    {
                        label: 'Close',
                        accelerator: 'CmdOrCtrl+W',
                        role: 'close'
                    },
                ]
            },
            {
                label: 'Help',
                role: 'help',
                submenu: [
                    {
                        label: 'Learn More',
                        click: function() { require('electron').shell.openExternal('https://ppmessage.com') }
                    },
                ]
            },
        ];

        if (process.platform == 'darwin') {
            var name = require('electron').remote.app.getName();
            template.unshift({
                label: name,
                submenu: [
                    {
                        label: 'About ' + name,
                        role: 'about'
                    },
                    {
                        type: 'separator'
                    },
                    {
                        label: 'Services',
                        role: 'services',
                        submenu: []
                    },
                    {
                        type: 'separator'
                    },
                    {
                        label: 'Hide ' + name,
                        accelerator: 'Command+H',
                        role: 'hide'
                    },
                    {
                        label: 'Hide Others',
                        accelerator: 'Command+Alt+H',
                        role: 'hideothers'
                    },
                    {
                        label: 'Show All',
                        role: 'unhide'
                    },
                    {
                        type: 'separator'
                    },
                    {
                        label: 'Quit',
                        accelerator: 'Command+Q',
                        click: function() {
                            var app = require("electron").remote.app;
                            app.quit();
                        }
                    },
                ]
            });
            
            // Window menu.
            template[3].submenu.push(
                {
                    type: 'separator'
                },
                {
                    label: 'Bring All to Front',
                    role: 'front'
                }
            );
        }
        
        return template;
    }
    
    function initMenu() {
        var remote = require("electron").remote;
        var Menu = remote.Menu;
        var template = getMenuTemplate();
        var menu = Menu.buildFromTemplate(template);
        Menu.setApplicationMenu(menu);
    }
    
    return {
        init: function () {
            if (yvSys.in_electron()) {
                initMenu();
            }
        }
    };
}]);

ppmessageModule.directive("yvMessage", [
    "$rootScope",
    "$timeout",
    "$ionicLoading",
    "$ionicActionSheet",
    "yvDB",
    "yvAPI",
    "yvSys",
    "yvLog",
    "yvUser",
    "yvMain",
    "yvFile",
    "yvBase",
    "yvMime",
    "yvType",
    "yvLink",
    "yvAlert",
    "yvLocal",
    "yvConstants",
function ($rootScope, $timeout, $ionicLoading, $ionicActionSheet, yvDB, yvAPI, yvSys, yvLog, yvUser, yvMain, yvFile, yvBase, yvMime, yvType, yvLink,
          yvAlert, yvLocal, yvConstants) {
        
    function _link($scope, $element, $attrs) {

        $scope.copyMessage = function (message) {
            var text = "";
            if (yvType.is_text(message)) {
                text = message.body;
            } else if (yvType.is_txt(message)) {
                text = message.txt_content;
            }
            return;
        };

        $scope.deleteMessage = function (message) {
            $scope.$parent.deleteMessage(message);
        };

        $scope.hold = function (message) {
            yvLog.log("holding.....");
            var _copy = "<center style='color: #007aff'>" + yvLocal.translate("app.GLOBAL.COPY") + "</center>";
            var _forward = "<center style='color: #007aff'>" + yvLocal.translate("app.GLOBAL.FORWARD") + "</center>";
            var _delete = "<center style='color: #ff3b30'>" + yvLocal.translate("app.GLOBAL.DELETE") + "</center>";
            var _cancel = "<center style='color: #007aff'>" + yvLocal.translate("app.GLOBAL.CANCEL") + "</center>";
            var _bs = null, _hide = null;

            if ($scope.$parent.conversation.history) {
                yvLog.log("converstion.history is true, don't show hold options");
                return;
            }

            
            _bs = [];
            _hide = $ionicActionSheet.show({
                buttons: _bs,

                destructiveText: _delete,
                destructiveButtonClicked: function () {
                    $scope.deleteMessage(message);
                    return true;
                },

                cancelText: _cancel,
                cancel: function () {
                    yvLog.log();
                },

                buttonClicked: function (_index) {
                    yvLog.log(_bs[_index]);
                    if (_bs[_index].text === _forward) {
                        $scope.$parent.showForwardModal(message);
                    }

                    if (_bs[_index].text === _copy) {
                        $scope.copyMessage(message);
                    }
                    return true;
                }
            });

            $timeout(function () {
                _hide();
            }, 5000);
        };

        $scope.dbclick = function (message) {
            yvLog.log('dbclick ...');
            if (yvType.is_text(message)) {
                $scope.$parent.showTextModal(message.body_linky);
            } else if (yvType.is_txt(message)) {
                $scope.$parent.showTextModal(message.txt_content_linky);
            }
            return;
        };

        $scope.openFile = function (file_url) {
            file_url = decodeURI(file_url);
            cordova.plugins.disusered.open(file_url, function () {
                $ionicLoading.hide();
            }, function (error_code) {
                $ionicLoading.hide();
                yvAlert.toast(yvLocal.translate("app.GLOBAL.CANT_OPEN_FILE"));
            });
        };

        $scope.handleNormalFile = function (message) {
            var file_name = message.name || (message.file + "." + yvSys.mime_ext(message.mime));
            
            $timeout(function () {
                yvAPI.download_web_material(message.file, message.name);
            }, 300);
        };

        $scope.click = function (message, event) {
            var s = message.status,
                S = yvConstants.SEND_STATUS;

            if (yvType.is_image(message)) {
                $scope.viewImage(message);
                return;
            }

            if (yvType.is_text(message)) {
                yvLink.open_link(event);
                return;
            }

            if (yvType.is_file(message)) {
                if (message.direction === yvConstants.MESSAGE_DIR.DIR_IN) {
                    $scope.handleNormalFile(message);
                    return;
                }
                if (s === S.SEND_SUCCESS || s === S.SEND_SENDING) {
                    $scope.handleNormalFile(message);
                    return;
                }
                return;
            }

            return;
        };

        $scope.isFileMessage = function (message) {
            return yvType.is_file(message);
        };

        $scope.isTextMessage = function (message) {
            return yvType.is_text(message);
        };

        $scope.isImageMessage = function (message) {
            return yvType.is_image(message);
        };

        $scope.viewImage = function (message) {
            yvLog.log(message.id, message.mime);

            function __show() {
                var image_url = yvLink.get_message_image(message);
                $ionicLoading.hide();
                $scope.$parent.showImageModal(image_url);
            }

            function __update_and_show(file) {
                message.file = file;
                __show();
                if (!$scope.message.in_history) {
                    yvMain.update_message_file(message, file);
                }
            }

            function __download() {
            }

            function __init() {
                if (message.file) {
                    __show();
                } else {
                    __download();
                }
            }

            __init();
        };

        $scope.showAlertIcon = function (message) {
            if (yvType.is_right(message) && message.status === yvConstants.SEND_STATUS.SEND_ERROR) {
                return true;
            }
            return false;
        };

        $scope.showMouth = function (message) {
            if (yvType.is_image(message)) {
                return false;
            }
            return true;
        };

        $scope.viewProfile = function (message) {
            $scope.message.show_profile = true;
        };

        // match with the directive yv-userinfo-settings.
        $scope.viewUserinfo = function (message) {
            if(message.direction == "DIR_OUT") {
                return;
            }

            $scope.$parent.showUserinfoModal(message.from_uuid);
            // $scope.message.show_userinfo = true;
         }

         // $scope.$on('close_userinfo', function(){
         //    $scope.message.show_userinfo = false;
         // });

        $scope.getUserIcon = function (message) {
            var user_uuid = message.from_uuid;
            var icon = null;

            if (yvType.is_right(message)) {
                user_uuid = yvUser.get("uuid");
            }

            icon = yvBase.get("object", user_uuid, "icon");
            return yvLink.get_user_icon(icon);
        };

        $scope.getMessageClass = function (message) {
            var _class = "";

            if (yvType.is_left(message)) {
                _class += " yv-left ";
            } else if (yvType.is_right(message)) {
                _class += " yv-right ";
            }

            _class += "yv-pc";
            return _class;
        };

        //if the interval chat message is more than one minute
        $scope.shouldShowTimestamp = function (message) {
            var _pre = $scope.$parent.timestamp.pre;

            // if existed, show it
            if (message.show_timestamp) {
                $scope.$parent.timestamp.pre = message.timestamp;
                return true;
            }

            message.show_timestamp = Math.abs(message.timestamp - _pre) > 60;
            if (message.show_timestamp) {
                $scope.$parent.timestamp.pre = message.timestamp;
            }
            return message.show_timestamp;
        };

        $scope.getTimestamp = function (message) {
            return yvLocal.format_timestamp(message.timestamp, true);
        };

        $scope.getFontStyle = function () {
            return {"font-size": "14px"};
        };

        function _init() {
            $scope.message.show_profile = false;
        }

        _init();
    }

    return {
        restrict: "E",
        scope: {
            message: "=",
            isLast: "="
        },
        link: _link,
        controller: "MessageCtrl",
        templateUrl: "templates/directives/message.html"
    };

}]);

ppmessageModule.directive("yvTextMessage", [function () {
    
    function link($scope, $element, $attrs, messageCtrl) {
        var text;
        if (!$scope.message.body_linky) {
            text = messageCtrl.getTrustedText($scope.message.body);
            $scope.message.body_linky = text;
            $element.html(text);
        } else {
            $element.html($scope.message.body_linky);
        }
        messageCtrl.scrollBottom();
    }
    
    return {
        restrict: "E",
        replace: true,
        require: "^yvMessage",
        scope: {
            message: "="
        },
        link: link,
        template: "<pre class='yv-chat-text'></pre>"
    };
    
}]);

ppmessageModule.directive("yvFileMessage", [
    "yvMime",
    "yvSys",
    "yvMain",
    "yvUploader",
    "yvConstants",
    "yvLocal",
function (yvMime, yvSys, yvMain, yvUploader, yvConstants, yvLocal) {

    function link($scope, $element, $attrs, messageCtrl) {
                
        function bytesToSize(bytes) {
            if (bytes == 0) {
                return '0 B';
            }
            var k = 1000, // or 1024
                sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
                i = Math.floor(Math.log(bytes) / Math.log(k));
            return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];
        }

        $scope.getMessageStatus = function (message) {
            switch (message.status) {
            case yvConstants.SEND_STATUS.SEND_CHECKING:
                return yvLocal.translate("app.GLOBAL.CHECKING_FILE");
            case yvConstants.SEND_STATUS.SEND_UPLOADING:
                return yvLocal.translate("app.GLOBAL.UPLOADING_FILE");
            case yvConstants.SEND_STATUS.SEND_SENDING:
                return yvLocal.translate("app.GLOBAL.SENDING");
            case yvConstants.SEND_STATUS.SEND_CANCELED:
                return yvLocal.translate("app.GLOBAL.CANCELED");
            default:
                return "";
            }
        };
        
        $scope.shouldShowProgress = function (message) {
            var _d = message.direction,
                _s = message.status;

            if (yvSys.in_ios_app()) {
                return false;
            }
            if (_d === yvConstants.MESSAGE_DIR.DIR_OUT && _s === yvConstants.SEND_STATUS.SEND_UPLOADING) {
                return true;
            }
            return false;
        };
        
        $scope.cancelUpload = function (message) {
            yvMain.update_message_status(message, yvConstants.SEND_STATUS.SEND_CANCELED);
            if (yvSys.in_android_app()) {
                message.ft.abort();
            } else {
                message.fileItem.cancel();
            }
            return {"width": "0%"};
        };
        
        $scope.getFileProgress = function (message) {
            var progress = (message.upload_progress || 0) + "%";
            return {"width": progress };
        };
        
        function init(m) {
            var body = {};
            
            if (m.body) {
                body = angular.fromJson(m.body);
            }
            
            if (body !== null) {
                m.mime = m.mime || body.mime || "";
                m.size = m.size || body.size || "";
                m.name = m.name || body.name || "";
                m.file = m.file || body.fid || "";
            }
            
            $scope.fileName = m.name;
            $scope.fileSize = bytesToSize(m.size);
            $scope.fileIcon = yvMime.mime_icon(m.mime);
            messageCtrl.scrollBottom();
        }
        
        init($scope.message);
    }
    
    return {
        restrict: "E",
        replace: true,
        require: "^yvMessage",
        scope: {
            message: "="
        },
        link: link,        
        templateUrl: "templates/directives/file-message.html"
    };
    
}]);

ppmessageModule.directive("yvImageMessage", [
    "$window",
    "yvLink",
    "yvSys",
    "yvFile",
    "yvMime",
    "yvAPI",
function($window, yvLink, yvSys, yvFile, yvMime, yvAPI) {

    var helper = {
        support: !!$window.FileReader,
        isFile: function(item) {
            return angular.isObject(item) && item instanceof $window.File;
        },
        isImage: function(file) {
            var type =  '|' + file.type.slice(file.type.lastIndexOf('/') + 1) + '|';
            return '|jpg|png|jpeg|bmp|gif|'.indexOf(type) !== -1;
        }
    };

    function link($scope, $element, $attrs, messageCtrl) {

        function renderElement(file) {
            var DEFAULT_IMAGE = yvLink.default_image_pic();
            var img = $element.find("img")[0];
            var reader = null;
            
            if (arguments === 0 || !file) {
                file = $scope.message.file || $scope.message.thumbnail;
            }
            
            // if it is the lastest message, content should scroll bottom when image is loaded
            if (messageCtrl.isLast) {
                img.onload = function (event) {
                    messageCtrl.scrollBottom();
                };
            }
            
            // show image message we receive
            if (!helper.isFile(file)) {
                img.src = yvLink.get_message_image($scope.message);
                return;
            }

            // show image message we sent
            if (helper.isImage(file)) {
                if (!helper.support) {
                    img.src = DEFAULT_IMAGE;
                    return;
                }
                reader = new FileReader();
                reader.onload = function(event) {
                    img.src = event.target.result || DEFAULT_IMAGE;
                };
                reader.readAsDataURL(file);
                return;
            }
        }

        function setThumb(thumbFile) {
            $scope.message.thumbnail = thumbFile;
            $scope.message.file = null;
            renderElement(thumbFile);
        }
        
        function init (message) {
            var body = {}, unregister = null;
            
            if (message.body) {
                body = angular.fromJson(message.body);
            }
            
            if (body.mime && message.mime === null) {
                message.mime = body.mime;
            }
            
            // in browser, file is either a fileItem or a file_uuid
            message.file = message.file || body.orig;
            renderElement();
            return;
        }

        init($scope.message);
    }

    return {
        restrict: 'E',
        replace: true,
        require: "^yvMessage",
        scope: {
            message: "="
        },
        link: link,
        template: '<div class="yv-chat-image"><img></div>'
    };

}]);

ppmessageModule.directive("yvDoubleClick", [
    "$timeout",
function ($timeout) {

    return {
        restrict: 'A',
        link: function ($scope, $element, $attr) {
            var clicks = 0;

            $element.bind('click', function (evt) {
                clicks++;
                if (clicks === 1) {
                    $timeout(function () {
                        if (clicks !== 1) {
                            $scope.$apply(function () {
                                $scope.$eval($attr.yvDoubleClick);
                            });
                        }
                        clicks = 0;
                    },  300);
                }
            });
        }
    };

}]);

ppmessageModule.directive('yvClick', [
    "$parse",
    "yvSys",
function($parse, yvSys) {

    function _link(scope, element, attrs) {
        var rightClick = $parse(attrs.yvRightClick);
        var leftClick = $parse(attrs.yvLeftClick);

        if (yvSys.in_pc()) {
            initPC();
        } else {
            initOther();
        }
        
        function initPC() {
            element[0].onmousedown = function (event) {
                var button = event.button;
                if (button === 0) {
                    leftClick(scope, {$event: event});
                }
                if (button === 2) {
                    rightClick(scope, {$event: event});
                }
            };
            
            element.bind('contextmenu', function(event) {
                scope.$apply(function() {
                    event.preventDefault();
                });
            });
        }

        function initOther() {
            $element.bind("click", function() {
                leftClick(scope, {$event: event});
            });
        }
    }

    return {
        restrict: "A",
        link: _link
    };
}]);

ppmessageModule.directive("yvChatTool", [
    "$timeout",
    "$ionicGesture",
    "yvLog",
    "yvSys",
    "yvNoti",
    "yvFile",
    "yvDelegate",
    "yvConstants",
function ($timeout, $ionicGesture, yvLog, yvSys, yvNoti, yvFile, yvDelegate, yvConstants) {

    function _controller($scope, $element, $attrs) {
        var _close_gesture = null;
        var _s = $scope.chatStatus;
        var _S = yvConstants.CHAT_STATUS;
        var _M = yvConstants.MESSAGE_SUBTYPE;

        $scope.$on("event:pause-listen-keyboard", function () {
            window.removeEventListener('native.keyboardhide', _on_hide);
            window.removeEventListener('native.keyboardshow', _on_show);
        });
        
        $scope.$on("event:resume-listen-keyboard", function () {
            $timeout(function () {
                window.addEventListener('native.keyboardhide', _on_hide);
                window.addEventListener('native.keyboardshow', _on_show);
            }, 1000);
        });
        
        function _on_keypress(event) {
            if (_s.status !== _S.TEXTING) {
                return;
            }
        }

        function _unregister_close_gesture() {
            if (_close_gesture !== null) {
                $ionicGesture.off(_close_gesture, "tap", _close_gesture_cb);
                _close_gesture = null;
            }
        }

        function _close_gesture_cb(e) {
            var _toolTop = $element.children()[0].offsetTop;

            if (e.gesture.touches[0].pageY >= _toolTop) {
                return;
            }
            
            if (_s.status === _S.RECORDING_PRE || _s.status === _S.ADDING) {
                $timeout(function () {
                    _s.status = _S.NULL;
                    yvDelegate.scroll_resize();
                });
                _unregister_close_gesture();
                return;
            }
        }

        function _register_close_gesture() {
            $timeout(function () {
                if (_close_gesture === null) {
                    _close_gesture = $ionicGesture.on("tap", _close_gesture_cb, angular.element(document));
                }
            }, 300);
        }

        function _on_hide() {
            _s.scroll = true;
        }

        function _on_show(e) {
            yvSys.set_keyboard_height(e.keyboardHeight);
            $timeout(function () {
                _s.status = _S.TEXTING;
                _s.scroll = true;
            });
        }

        function _change_status(target_status) {
            if ($scope.chatStatus.status == target_status) {
                $scope.chatStatus.status = _S.NULL;
                yvDelegate.scroll_bottom();
                return;
            }
            
            if ($scope.chatStatus.status == _S.TEXTING) {
                if (yvSys.in_mobile_browser()) {
                    $timeout(function () {
                        $scope.chatStatus.status = target_status;
                        yvDelegate.scroll_bottom();
                    }, 400);
                    return;
                }
            }
            
            $scope.chatStatus.status = target_status;
            yvDelegate.scroll_bottom();
            return;
        }
        
        $scope.getPlatformClass = function() {
            if (yvSys.in_mobile_browser()) {
                return "yv-mobile-browser";
            }
            return "";
        };
        
        $scope.showMicButton = function () {
            if (_s.status === _S.RECORDING_PRE || _s.status === _S.RECORDING || _s.status === _S.RECORDING_CANCEL) {
                return true;
            }
            return false;
        };

        $scope.showAddingButton = function () {
            if (_s.status === _S.ADDING) {
                return true;
            }
            return false;
        };

        $scope.getToolbarBottom = function () {
            var _b = 0;
            if (_s.status === _S.NULL) {
                if (_s.scroll) {
                    yvDelegate.scroll_bottom();
                    _s.scroll = false;
                }
                return {"bottom": _b + "px"};
            }

            if (_s.status === _S.TEXTING) {
                return {"bottom": _b + "px"};
            }

            if (_s.status === _S.RECORDING_PRE || _s.status === _S.ADDING) {
                _b = yvSys.get_keyboard_height();
                return {"bottom": _b + "px"};
            }

            return {"bottom": _b + "px"};
        };

        $scope.getAddPageStyle = function () {
            return {"height":  yvSys.get_keyboard_height() + "px"};
        };

        $scope.selectToAdd = function () {
            _register_close_gesture();
            _change_status(_S.ADDING);
        };
        
        $scope.selectToSound = function () {
            _register_close_gesture();
            _change_status(_S.RECORDING_PRE);
        }; 
        
        // fixme: chat-tool doesn't rise up when keyboard show
        $scope.onTextareaBlur = function () {
            console.log("INPUT BLURED..... sending " + _s.sending + " status:" + _s.status);
            if (_s.status === _S.TEXTING && _s.sending === true) {
                $scope.textarea.element[0].style.height = $scope.textarea.origin_height;
                $scope.textarea.element[0].focus();
                _s.sending = false;
                return;
            }
            
            if (_s.status === _S.TEXTING && _s.sending === false) {
                $timeout(function () {
                    _s.status = _S.NULL;
                }, 0);
                return;
            }
        };

        $scope.focusToText = function () {
            _unregister_close_gesture();

            if (yvSys.in_mobile_browser()) {
                $timeout(function () {
                    _s.status = _S.TEXTING;
                    yvDelegate.scroll_bottom();
                });
            }
        };

        $scope.prepareText = function () {
            if (!$scope.textarea.text) {
                return;
            }
            var text = $scope.textarea.text,
                len = yvSys.encode_utf8(text).length;
            $scope.sendMessage({type: _M.TEXT, data: text});
            $scope.textarea.text = "";
            $scope.textarea.element[0].focus();
            $scope.textarea.element[0].style.height = $scope.textarea.origin_height;
            _s.sending = true;
        };
        
        $scope.$on("$destroy", function () {
            _unregister_close_gesture();
            if ($scope.conversation) {
                $scope.conversation.last_chat_text = $scope.textarea.text;
            }
        });

        function _init() {
            $scope.textarea = {
                text: "",
                origin_height: "25px",
                element: $element.find("textarea")
            };
            
            _s.status = yvConstants.CHAT_STATUS.NULL;
            _s.sending = false;

            if ($scope.conversation && $scope.conversation.last_chat_text) {
                $scope.textarea.text = $scope.conversation.last_chat_text;
            }

            $scope.onKeyPress = _on_keypress;            
        }
        
        _init();
    }

    _controller.$inject = ["$scope", "$element", "$attrs"];

    return {
        restrict: "EA",
        templateUrl: 'templates/directives/chat-tool.html',
        controller: _controller
    };

}]);

ppmessageModule.directive("yvDynamicHeight", [function () {

    function _link($scope, $element, $attr) {
        /**
         * 文本框根据输入内容自适应高度
         * @param {HTMLElement}        输入框元素
         * @param {Number}             设置最大高度(可选)
         * @param {Number}             设置光标与输入框保持的距离(默认0)
         */
        function autoTextarea(elem, maxHeight, extra) {
            extra = extra || 0;

            function addEvent(type, callback) {
                elem.addEventListener(type, callback, false);
            }

            function getStyle(name) {
                return window.getComputedStyle(elem, null)[name];
            }

            var minHeight = parseFloat(getStyle('height'));

            elem.style.resize = 'none';

            function change() {
                var scrollTop,
                    height,
                    padding = 0,
                    style = elem.style;

                if (elem._length === elem.value.length) {
                    return;
                }

                elem._length = elem.value.length;
                padding = window.parseInt(getStyle('paddingTop')) + window.parseInt(getStyle('paddingBottom'));

                scrollTop = document.body.scrollTop || document.documentElement.scrollTop;

                elem.style.height = minHeight + 'px';

                if (elem.scrollHeight > minHeight) {
                    if (maxHeight && elem.scrollHeight > maxHeight) {
                        height = maxHeight - padding;
                        style.overflowY = 'auto';
                    } else {
                        height = elem.scrollHeight - padding;
                        style.overflowY = 'auto';
                    }

                    style.height = height + extra + 'px';
                    scrollTop += window.parseInt(style.height) - elem.currHeight;
                    document.body.scrollTop = scrollTop;
                    document.documentElement.scrollTop = scrollTop;
                    elem.currHeight = window.parseInt(style.height);
                }
            }

            addEvent('input', change);
        }

        autoTextarea($element[0], 80);
    }

    return {
        restrict: "C",
        link: _link
    };
}]);

ppmessageModule.directive("yvNewChatTool", [
    "$timeout",
    "yvLog",
    "yvSys",
    "yvAPI",
    "yvUser",
    "yvNoti",
    "yvConstants",
    "yvUploader",
    "yvDelegate",
function ($timeout, yvLog, yvSys, yvAPI, yvUser, yvNoti, yvConstants, yvUploader, yvDelegate) {

    // function _link($scope, $element, $attr) {
    function _controller($scope, $element, $attrs) {
        
        $scope.prepareText = function () {
            if ($scope.textarea.text === "") {
                console.error("can't send empty message");
                return;
            }
            
            var _text = $scope.textarea.text,
                _len = yvSys.encode_utf8(_text).length,
                _form = $element.find("form")[0];

            $scope.sendMessage({
                type: yvConstants.MESSAGE_SUBTYPE.TEXT,
                data: _text
            });
            
            $timeout(function () {
                $scope.textarea.text = "";
                $element.find("textarea")[0].focus();
            });
        };

        $scope.onKeyPress = function (event) {
            var code = event.keyCode || event.which;
            if (code == 13 || code == 10) {
                event.preventDefault();
                if (event.ctrlKey) {
                    $scope.textarea.text += "\n";
                } else {
                    $scope.prepareText();
                }
            }
        };

        $scope.onFocus = function () {
            //Jin He: it works in Safari, but not in Chrome
            if ($scope.inMobileChrome()) {
                yvDelegate.scroll_bottom();
            }
        };

        $scope.uploadFile = function () {
            angular.element("input#send-file").click();
        };
        
        $scope.sendLocation = function () {
            $scope.$broadcast("event:show-send-location-modal");
        };

        $scope.getPlatformClass = function () {
            var _class = "";

            if (yvSys.in_mobile_browser()) {
                _class += " yv-mobile ";
            } else {
                _class += " yv-pc ";
            }

            return _class;
        };
        
        $scope.inMobileChrome = function () {
            return yvSys.in_mobile_browser();
        };

        $scope.$on("event:restore-chat-text", function (event, conversation) {
            if (conversation && conversation.last_chat_text) {
                $scope.textarea.text = conversation.last_chat_text;
            } else {
                $scope.textarea.text = "";
            }
        });
        
        $scope.$on("event:save-chat-text", function (event, conversation) {
            if (conversation) {
                conversation.last_chat_text = $scope.textarea.text;
            }
        });
        
        function _init() {
            $scope.textarea = {text: ""};
            var _server = yvAPI.get_server();
            $scope.uploaderOptions = {
                url: _server.upload_url,
                formData: [{upload_type: "file", user_uuid: yvUser.get("uuid")}]
            };
            $scope.uploader = yvUploader.get_uploader();
        }

        _init();
    }

    _controller.$inject = ["$scope", "$element", "$attrs"];

    return {
        restrict: "E",
        templateUrl: 'templates/directives/new-chat-tool.html',
        controller: _controller
    };

}]);

ppmessageModule.directive('hideTabBar', [
    "$state",
    "$timeout",
    "yvSys",
function ($state, $timeout, yvSys) {
    function _compile(element, attr) {
        var tabBar = document.querySelector('.tab-nav');
        var tabState = ["app.conversation-list-mobile", "app.contact-list-mobile", "app.setting-list-mobile"];

        function isTabState() {
            var state = $state.current.name;
            return (tabState.indexOf(state) != -1);
        }
        
        return function ($scope, $element, $attr) {
            if (!yvSys.in_mobile()) {
                return;
            }
            var scroll = $element[0].querySelector('.scroll-content');
            $scope.$on('$ionicView.beforeLeave', function () {
                if (isTabState()) { return; }
                tabBar.classList.add('slide-away');
                // scroll.classList.add('no-tabs');
            });
            $scope.$on('$ionicView.beforeEnter', function () {
                tabBar.classList.remove('slide-away');
                // scroll.classList.remove('no-tabs');
            });
        };
    }

    return {
        restrict: 'A',
        compile: _compile
    };
}]);

ppmessageModule.directive("yvCropImage", [
    "yvLink",
    "yvConstants",
function (yvLink, yvConstants) {

    /* This directive is intended to work in pc-browser, mobile-browser, electron, NOT INCLUDING mobile-native !
     * It is used together with controller: changeAvatarCtrl.
     */
    
    function _link($scope, $element, $attrs) {
        var jcrop_api = null;
        var thumbnail = null;
        var img = $element.find("img#target-image");
        var thumb_width = yvConstants.AVATAR.WIDTH;
        var thumb_height = yvConstants.AVATAR.HEIGHT;
        var thumb_size = {
            width: thumb_width,
            height: thumb_height
        };
        var options = {
            boxWidth: 600,
            boxHeight: 400,
            aspectRatio: 1,
            minSize: [thumb_width, thumb_height],
            setSelect: [100, 100, 400, 400]
        };

        setCurrentAvatar();

        $scope.$on("event:restore-avatar", function (event, callback) {
            restore(callback);
        });

        
        $scope.$on("event:crop-avatar", function (event, callback) {
            cropAvatar(callback);
        });

        
        // CR: use jcrop_api.setImage rather than jcrop_api.destroy
        $scope.$watch("imgSrc", function (new_src, old_src) {
            if (!new_src) {
                return;
            }
            if (jcrop_api) {
                jcrop_api.destroy();
            }
            img.attr("src", new_src);
            initJcrop();
        });

        
        function setCurrentAvatar() {
            $scope.userIcon = yvLink.current_user_avatar();
        }
        
        
        function setDirty(bool) {
            $scope.$emit("event:set-dirty", !!bool);
        }

        
        function initJcrop() {
            img.Jcrop(options, function () {
                jcrop_api = this;
                thumbnail = this.initComponent("Thumbnailer", thumb_size);
                setDirty(true);
            });
        }

        
        function dataURLtoBlob(dataurl) {
            var arr = dataurl.split(',');
            var mime = arr[0].match(/:(.*?);/)[1];
            var bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], {type:mime});
        }


        function getTrueSelection(selection, scale) {
            return {
                x: Math.round(selection.x / scale.x),
                y: Math.round(selection.y / scale.y),
                x2: Math.round(selection.x2 / scale.x),
                y2: Math.round(selection.y2 / scale.y),
                w: Math.round(selection.w / scale.x),
                h: Math.round(selection.h / scale.y),
            };
        }
        
        
        function cropAvatar (callback) {
            if (!jcrop_api) {
                return;
            }
            
            var selection = jcrop_api.getSelection();
            var container_size = jcrop_api.getContainerSize();
            
            var scale = {
                x: container_size[0] / $("#target-image")[0].naturalWidth,
                y: container_size[1] / $("#target-image")[0].naturalHeight
            };
            
            var s = getTrueSelection(selection, scale);

            var s1 = $("#target-image").Jcrop('api').getSelection();
            var s2 = $("#target-image").width();
            
            var avatar = document.createElement("canvas");
            avatar.width = thumb_width;
            avatar.height = thumb_height;
            var context = avatar.getContext("2d");
            context.drawImage($("#target-image")[0], s.x, s.y, s.w, s.h, 0, 0, thumb_width, thumb_height);

            var data_url = avatar.toDataURL();
            var blob = dataURLtoBlob(data_url);
            // var file = new File([blob], "avatar-blob", {type: blob.type});
            // callback && callback(blob, file);

            // NOTICE: Safari, IE, Edge doesn't support File constructor.
            // So we wont't construct a File, just return blob.
            callback && callback(blob);

        }

        
        function restore(callback) {
            if (!jcrop_api) {
                return;
            }
            jcrop_api.destroy();
            jcrop_api = null;
            setDirty(false);
            setCurrentAvatar();
            img.attr("src", null);
            callback && callback();
        };
        
    }
    
    return {
        restrict: "E",
        replace: true,
        scope: {
            imgSrc: "=",
            isDirty: "="
        },
        link: _link,
        templateUrl: "templates/directives/crop-image.html"
    };
}]);

ppmessageModule.directive("yvChangeAvatar", [
    "$timeout",
    "$ionicLoading",
    "$ionicActionSheet",
    "yvSys",
    "yvAPI",
    "yvMain",
    "yvUser",
    "yvFile",
    "yvLocal",
    "yvConstants",
function ($timeout, $ionicLoading, $ionicActionSheet, yvSys, yvAPI, yvMain, yvUser, yvFile, yvLocal, yvConstants) {

    /* This directive is intended to work in ONLY mobile-native. Different from controller: changeAvatarCtrl,
     * it pop up a actionSheet for user to change avatar, rather than open a new page.
     */
    
    function _link($scope, $element, $attrs) {
        var actionSheet = null;
        
        $element.on("click", function (event) {
            return;
        });


        function startLoading() {
            $ionicLoading.show({
                duration: 5000,
                template: "<ion-spinner></ion-spinner>"
            });
        }

        
        function finishLoading() {
            $ionicLoading.hide();
        }

        
        function createAvatarFile(dataUrl, callback) {
            yvFile.create_random(dataUrl, true, function (fileName) {
                callback && callback(fileName);
            });
        }

        
        function createCanvasDataURL(img, dx, dy, w, h) {
            var canvas = document.createElement("canvas");
            var context = canvas.getContext("2d");
            canvas.width = yvConstants.AVATAR.WIDTH;
            canvas.height = yvConstants.AVATAR.HEIGHT;
            context.drawImage(img, dx, dy, w, h, 0, 0, canvas.width, canvas.height);            
            return canvas.toDataURL("image/jpeg", 1);
        }

        
        function dataURLtoFile(dataUrl, callback) {
            var img = document.createElement("img");
            img.onload = function (event) {
                var imgWidth = img.width;
                var imgHeight = img.height;
                // If the crop process works well, this will be the case
                if (imgWidth == yvConstants.AVATAR.WIDTH && imgHeight == yvConstants.AVATAR.HEIGHT) {
                    createAvatarFile(dataUrl, callback);
                    return;
                }
                // Should we crop the image when image size is not 140x140 ?
                // Currently we just scale image to 140x140, seems not bad.
                dataUrl = createCanvasDataURL(img, 0, 0, imgWidth, imgHeight);
                dataUrl = dataUrl.split(",")[1];
                createAvatarFile(dataUrl, callback);
            };
            img.src = "data:image/jpeg;base64," + dataUrl;
        }
        

        function saveAvatar(fileName) {
            yvAPI.upload_file(fileName, "image/jpeg", function(response) {
                if (!response) {
                    return;
                }
                response = JSON.parse(response);
                yvAPI.update_user({ user_icon: response.fuuid }, function() {
                    $timeout(function () {
                        finishLoading();
                        yvMain.update_current_user("icon", fileName);
                    });
                });
            });
        }

        
        function cropAvatar(choosePicture) {
            // In Android, setting destinationType to be Camera.DestinationType.FILE_URL results in invalid
            // image-crop (the saved file would be the origin image, not the cropped image). In iOS, both
            // Camera.DestinationType.DATA_URL and Camera.DestinationType.FILE_URL works. The Plugin itself
            // says options.allowEdit should not be used in Android, because it is unpredictable, but we have
            // not another choice.
            var options = {
                quality: 100,
                allowEdit: true,
                targetWidth: yvConstants.AVATAR.WIDTH,
                targetHeight: yvConstants.AVATAR.HEIGHT,
                encodingType: Camera.EncodingType.JPEG,
                destinationType: Camera.DestinationType.DATA_URL,
                sourceType: choosePicture ? Camera.PictureSourceType.PHOTOLIBRARY : Camera.PictureSourceType.CAMERA,
            };
            
            // Including a JavaScript alert() in either of the callback functions can cause problems.
            // Wrap the alert within a setTimeout() to allow the iOS image picker or popover to fully
            // close before the alert displays:
            navigator.camera.getPicture(function (dataUrl) {
                startLoading();
                dataURLtoFile(dataUrl, function (fileName) {
                    saveAvatar(fileName);
                });
            }, function (message) {
                console.log("camera fail because: ", message);
            }, options);
        };

        
        // used to delay closing actionSheet after click button 
        function closeActionSheet(delay) {
            if (!delay || typeof delay !== "number") {
                delay = 0;
            }
            $timeout(function () {
                if (actionSheet) {
                    actionSheet();
                    actionSheet = null;
                }
            }, delay);
        }

        
        function showActionSheet() {
            actionSheet = $ionicActionSheet.show({
                cssClass: "change-avatar-action-sheet",
                cancelText: yvLocal.translate("app.GLOBAL.CANCEL"),
                cancel: function() {
                    closeActionSheet();
                },
                buttons: [
                    { text: yvLocal.translate("app.settings.profile_photo.TAKE_PHOTO_TAG") },
                    { text: yvLocal.translate("app.settings.profile_photo.CHOOSE_FROM_PHOTOS_TAG") }
                ],
                // Note: If button-clicked-callback return true, actionSheet will be closed In this
                // page (app.setting-list), if actionSheet closes upon button clicked, the LOGOUT
                // button could be accidently clicked, which would result in unwanted logout ...
                buttonClicked: function(index) {
                    closeActionSheet(100);
                    if (index === 0) {
                        cropAvatar(false);
                        return false;
                    }
                    if (index === 1) {
                        cropAvatar(true);
                        return false;
                    }
                    return true;
                }
            });
        }                
    }
    
    return {
        restrict: "A",
        replace: true,
        scope: true,
        link: _link
    };

}]);

ppmessageModule.directive("yvImageModal", [
    "$timeout",
    "$ionicModal",
    "$ionicActionSheet",
    "$ionicScrollDelegate",
    "yvAlert",
    "yvSys",
    "yvLocal",
function ($timeout, $ionicModal, $ionicActionSheet, $ionicScrollDelegate, yvAlert, yvSys, yvLocal) {

    function _link($scope, $element, $attr) {


        $scope.showModal = function () {
            $ionicScrollDelegate.$getByHandle("image-scroll").zoomTo(1);
            $scope.imageModal.show();
        };

        $scope.closeModal = function () {
            $scope.hide.bars = false;
            $scope.imageModal.hide();
        };

        $scope.onHold = function () {
        };
        
        $scope.saveImage = function () {
            // In PC. right click the image to save
        };

        $scope.showSaveButton = function () {
            return false;
        };

        $scope.toggleHide = function () {
            $scope.hide.bars = !$scope.hide.bars;
        };

        $scope.$on("event:show-image-modal", function (event, image) {
            if ((yvSys.in_browser() || yvSys.in_electron()) && yvSys.is_image_file(image)) {
                yvSys.read_image_file(image, function (dataUrl) {
                    $scope.imgSrc = dataUrl;
                });
            } else {
                $scope.imgSrc = image;
            }
            $scope.showModal();
        });
        
        $scope.$on('$destroy', function () {
            $scope.imageModal.remove();
        });

        function _init() {
            $scope.hide = {
                bars: false
            };
            $scope.disable = {
                save: false
            };
            $ionicModal.fromTemplateUrl('image-modal.html', {
                scope: $scope,
                animation: 'slide-in-up'
            }).then(function (modal) {
                $scope.imageModal = modal;
            });
        }

        _init();

    }

    return {
        restrict: "E",
        scope: true,
        templateUrl: "templates/directives/imagemodal.html",
        link: _link
    };
}]);

ppmessageModule.directive("yvTextModal", [
    "$ionicModal",
    "yvSys",
    "yvLink",
function ($ionicModal, yvSys, yvLink) {

    function _link($scope, $element, $attr) {

        $ionicModal.fromTemplateUrl('text-modal.html', {
            scope: $scope,
            animation: 'slide-in-up'
        }).then(function (modal) {
            $scope.textModal = modal;
            $scope.inMobile = yvSys.in_mobile();
        });

        $scope.showModal = function () {
            $scope.textModal.show();
        };

        $scope.closeModal = function (event) {
                $scope.textModal.hide();
        };

        $scope.clickContent = function (event) {
            yvLink.open_link(event);
        };
        
        $scope.$on("event:show-text-modal", function (event, content) {
            $scope.content = content;
            $scope.showModal();
        });

        $scope.$on('$destroy', function () {
            $scope.textModal.remove();
        });

    }

    return {
        restrict: "E",
        scope: true,
        templateUrl: "templates/directives/textmodal.html",
        link: _link
    };

}]);

ppmessageModule.directive("yvSidemenuHeader", [
    "$rootScope",
    "yvSys",
    "yvAPI",
    "yvLink",
    "yvUser",
    "yvBase",
    "yvLogin",
    "yvLogout",
    "yvLocal",
    "yvConstants",
function ($rootScope, yvSys, yvAPI, yvLink, yvUser, yvBase, yvLogin, yvLogout, yvLocal, yvConstants) {

    function link($scope, $element, $attrs) {
        
        $scope.page = {"show_popover": false};

        $scope.search = {
            searchKey: "",
            conversations: [],
            contacts: []
        };

        $scope.status = {
            options: [
                {
                    class: "bg-ready",
                    status: yvConstants.USER_STATUS.READY,
                    origin: "app.GLOBAL.READY",
                    content: yvLocal.translate("app.GLOBAL.READY")
                },
                {
                    class: "bg-busy",
                    status: yvConstants.USER_STATUS.BUSY,
                    origin: "app.GLOBAL.BUSY",
                    content: yvLocal.translate("app.GLOBAL.BUSY")
                },
                {
                    class: "bg-rest",
                    status: yvConstants.USER_STATUS.REST,
                    origin: "app.GLOBAL.REST",
                    content: yvLocal.translate("app.GLOBAL.REST")
                }
            ],
        };
        
        setSelectedStatus(yvUser.get("status"));

        function setSelectedStatus(status) {
            var option = null, i;
            var len = $scope.status.options.length;
            for (i = 0; i < len; i++) {
                option = $scope.status.options[i];
                if (option.status === status) {
                    $scope.status.selected = option;
                    break;
                }
            }
        }

        $rootScope.$on("$translateChangeSuccess", function (event) {
            angular.forEach($scope.status.options, function (option) {
                option.content = yvLocal.translate(option.origin);
            });
        });
        
        $scope.getUserIcon = function () {
            var _icon = yvUser.get("icon");
            return yvLink.get_user_icon(_icon);
        };

        
        $scope.getUserFullname = function () {
            return yvUser.get("fullname");
        };

        
        $scope.getCurrentAppName = function () {
            return yvUser.get("app").app_name;
        };
        
        
        $scope.showPopover = function () {
            $scope.page.show_popover = !$scope.page_show_popover;
        };


        $scope.logout = function () {
            yvLogout.logout();
        };

        
        $scope.clickItem = function () {
            $scope.clearSearchKey();
        };

        
        $scope.onStatusChange = function () {
            console.log($scope.status.selected);
            var old_status = yvUser.get("status");
            var new_status = $scope.status.selected.status;
            yvAPI.set_user_status(new_status, function (res) {
                yvUser.set("status", new_status);
                console.log(res);
            },__error, __error);

            function __error() {
                setSelectedStatus(old_status);
            }
        };
        
        
        $scope.selectStatus = function () {       
            var elem = angular.element("#user-status");
            if (document.createEvent) {
                var e = document.createEvent("MouseEvents");
                e.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                elem[0].dispatchEvent(e);
            } else if (element.fireEvent) {
                elem[0].fireEvent("onmousedown");
            }
        };

        
        $scope.startSearch = function () {
            var my_uuid = yvUser.get("uuid");
            var reg = new RegExp($scope.search.searchKey);
            $scope.search.conversations.length = 0;
            $scope.search.contacts.length = 0;
            if (!$scope.search.searchKey) {
                return;
            }
            angular.forEach(yvBase.get_list("conversation"), function (conv) {
                if (reg.test(conv.name)) {
                    $scope.search.conversations.push(conv);
                    return;
                }
                if (conv.type == yvConstants.CONVERSATION_TYPE.P2S) {
                    var user_name = yvBase.get("object", conv.user_uuid, "fullname");
                    if (reg.test(user_name)) {
                        $scope.search.conversations.push(conv);                        
                    }
                } 
            });
            angular.forEach(yvBase.get_list("contact"), function (contact) {
                if (reg.test(contact.fullname) && contact.uuid !== my_uuid) {
                    $scope.search.contacts.push(contact);
                } 
            });
        };

        
        $scope.clearSearchKey = function () {
            $scope.search.searchKey = "";
        };
    }
    
    return {
        restrict: "E",
        replace: true,
        scope: true,
        link: link,
        templateUrl: "templates/directives/sidemenu-header.html"
    };
    
}]);

ppmessageModule.directive("yvConversation", [
    "$state",
    "$timeout",
    "$rootScope",
    "yvSys",
    "yvAPI",
    "yvLog",
    "yvMain",
    "yvLink",
    "yvLocal",
    "yvBase",
    "yvMessage",
    "yvDelegate",
    "yvConstants",
function ($state, $timeout, $rootScope, yvSys, yvAPI, yvLog, yvMain, yvLink, yvLocal, yvBase, yvMessage, yvDelegate, yvConstants) {

    function link($scope, $element, $attrs) {
        var delegate = yvDelegate.get_list_delegate("conversation-list");

        $scope.isOnline = function (conversation) {
            return yvMain.is_conversation_online(conversation);
        };

        $scope.getIcon = function (conversation) {
            var icon = null;
            if (conversation.type === yvConstants.CONVERSATION_TYPE.P2S) {
                icon = yvBase.get("object", conversation.user_uuid, "icon");
            } else {
                icon = conversation.icon;
            }
            return yvLink.get_user_icon(icon);
        };


        $scope.getConversationName = function (conversation) {
            if (conversation.type === yvConstants.CONVERSATION_TYPE.P2S) {
                return yvBase.get("object", conversation.user_uuid, "fullname");
            } else {
                return conversation.name;
            }
        };


        $scope.getTimestamp = function (conversation) {
            var message = conversation.latest_message;
            if (!message) {
                return "";
            }
            return yvLocal.format_timestamp(message.timestamp) || "";
        };


        $scope.getTitle = function (conversation) {
            var message = conversation.latest_message;
            if (!message) {
                return "";
            }
            return yvMessage.localize_title(message.title) || "";
        };


        $scope.getUnread = function (conversation) {
            var count = conversation.unread;
            return count > 99 ? "99+" : count;
        };

        $scope.deleteConversation = function (conversation, event) {
            event.stopPropagation();
            delegate.closeOptionButtons();
            if (conversation === yvBase.active("conversation")) {
                yvBase.active("conversation", null);
                if (yvSys.in_pc()) {
                    $rootScope.$broadcast("event:open-conversation", null);
                }
            }
            yvMain.delete_conversation(conversation);
            yvAPI.close_conversation(conversation.uuid);            
        };


        $scope.showContextMenu = function (event) {
            console.log("---------right click", event);
            console.log("broadcast the event");
            $scope.$parent.$parent.$broadcast("event:open-menu", event, $scope.conversation);
        };


        $scope.markAsRead = function (conversation, event) {
            event.stopPropagation();
            delegate.closeOptionButtons();
            yvMain.unread_zero(conversation);
        };


        $scope.openConversation = function (conversation) {
            var _params = {
                conv_uuid: conversation.uuid,
                conv_type: conversation.type,
                user_uuid: conversation.user_uuid
            };

            console.log(">>>>> Click conversaiton: ", conversation);
            delegate.closeOptionButtons();

            if (yvSys.in_pc() && $state.is("app.conversation-list") && conversation.active) {
                return;
            }

            yvBase.active("conversation", conversation);
            if (yvSys.in_pc()) {
                if ($state.is("app.conversation-list")) {
                    $rootScope.$broadcast("event:open-conversation", _params);
                } else {
                    $state.go("app.conversation-list", _params);
                }
            } else {
                $state.go("app.conversation-list-mobile");
                $timeout(function () {
                    $state.go("app.conversation-mobile", _params);
                });
            }
        };

        function _init() {
            $scope.isDesktop = yvSys.in_pc_browser() || yvSys.in_electron();

            // $element.on("contextmenu", function(e) {
            //     if (e.preventDefault) {
            //         e.preventDefault();
            //     } else {
            //         windows.event.returnValue = false;
            //     }
            //     $scope.$broadcast('event:open-menu', e);
            // });
        };

        _init();

    }

    return {
        restirct: "E",
        replace: true,
        scope: {
            conversation: "=",
        },
        link: link,
        templateUrl: "templates/directives/conversation.html"
    };

}]);

ppmessageModule.directive("yvContact", [
    "$state",    
    "$timeout",
    "$rootScope",
    "yvSys",
    "yvBase",
    "yvLink",
function ($state, $timeout, $rootScope, yvSys, yvBase, yvLink) {

    function link($scope, $element, $attrs) {
        
        $scope.getIcon = function (contact) {
            var icon = yvBase.get("object", contact.uuid, "icon");
            return yvLink.get_user_icon(icon);
        };

        
        $scope.getFullname = function (contact) {
            return contact.fullname;
        };


        $scope.getContactClass = function (contact) {
            if (yvSys.in_mobile()) {
                return "";
            }            
            if (contact === yvBase.active("contact")) {
                return "active";
            }
            return "";
        };
        
        
        $scope.viewDetail = function (contact) {
            if (contact === yvBase.active("contact")) {
                if ($state.is("app.contact-list") && (yvSys.in_pc())) {
                    return;
                }
            }
            
            yvBase.active("contact", contact);
            
            if (yvSys.in_pc()) {
                if ($state.is("app.contact-list")) {
                    $rootScope.$broadcast("event:view-contact", contact.uuid);
                } else {
                    $state.go("app.contact-list", {"contact_uuid": contact.uuid});
                }
            } else {
                $state.go("app.contact-list-mobile");
                $timeout(function () {
                    $state.go("app.contact-mobile", {"contact_uuid": contact.uuid});
                });
            }
        };

    }
    
    return {
        restrict: "E",
        replace: true,
        scope: {
            contact: "="
        },
        link: link,
        templateUrl: "templates/directives/contact.html"
    };

}]);

ppmessageModule.directive('yvRightclickMenu', [
    "$timeout",
    "yvSys",
function ($timeout, yvSys) {
    
    function _link($scope, $element, $attr) {

        // $scope.unread = $attr[conversation].unread;

        function rightclickEvent(event) {
            
            var e = event || window.event;

            // prevent the default menu of browser.
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }

            var x = e.pageX || e.clientX + scrollX;
            var y = e.pageY || e.clientY + scrollY;

            $scope.isShow = true;
            $scope.startX = x;
            $scope.startY = y;

            $scope.menuStyle = {
                top: startX,
                right: startY
            }

            function clickEventListener(event) {
                $scope.click_count += 1;
                if ($scope.click_count === 1) {
                    return;
                }
                if (!event.target.hasAttribute("yv-menu")) {
                    $scope.isShow = false;
                    document.removeEventListener('click', clickEventLister);
                }
            };

            document.addEventListener('click', clickEventListener);

        };

        function _init() {
            $element.on('contextmenu', rightclickEvent);
        };

        _init();
    }

    return {
        restrict: 'EA',
        scope: {
            conversation: "="
        },
        link: _link,
        templateUrl: "templates/directives/rightclickmenu.html"
    };
}]);

ppmessageModule.controller("NoAppCtrl", [
    "$scope",
    "yvSys",
    "yvConstants",
function ($scope, yvSys, yvConstants) {
    $scope.showServerButton = function () {
        return ppmessage.developer_mode && yvSys.has_db();
    };

}]);

ppmessageModule.controller("MainWithLogoCtrl", [
    "$scope",
    "yvSys",
    "yvNav",
    "yvMain",
    "yvUser",
    "yvLogin",
    "yvConstants",
function ($scope, yvSys, yvNav, yvMain, yvUser, yvLogin, yvConstants) {

    function nav_login(user) {
        yvNav.clear(function () {
            if (!user) {
                return yvNav.login_no_user();
            }
            if (user.is_online && yvSys.has_db()) {
                return yvLogin.login_with_session(user);
            }
            yvNav.login_with_user(user);
        });
    }

    function init() {

        yvMain.init_yvdb(function (user) {
            nav_login(user);
        });
    }

    init();
}]);

ppmessageModule.controller("AutoLoginCtrl", [
    "$scope",
    "$state",
    "$stateParams",
    "$ionicHistory",
    "yvNav",
    "yvMain",
    "yvLogin",
    "yvUtil",
function ($scope, $state, $stateParams, $ionicHistory, yvNav, yvMain, yvLogin, yvUtil) {
        
    function login_success() {
        console.log("login successfully...");
    }

    function login_error(reason) {
        console.log("login error:", reason);
        yvNav.disable_next();
        $state.go("noapp.login-error");
    }

    $scope.$on("event:login-error", function (event, error) {
        console.error(error);
    });
    
    function init() {
        $scope.user = {
            request_body: $stateParams.request_body,
        };

        if (!$scope.user.request_body || $scope.user.request_body.length == 0) {
            login_error();
            return;
        }

        var _body_str = yvUtil.base64_decode($scope.user.request_body);
        _body = JSON.parse(_body_str);
        $scope.user.user_email = _body.user_email;
        $scope.user.user_password = _body.user_password;
        var current_session = yvLogin.current_session();
        if (current_session && current_session.user_email == _body.user_email) {
            $ionicHistory.goBack();
            return;
        }
        yvMain.init_yvdb(function (user) {
            yvLogin.login($scope.user);
        });
    }

    init();
}]);

ppmessageModule.controller("LoginErrorCtrl", [
    "$scope",
    "$timeout",
    "yvNav",
function ($scope, $timeout, yvNav) {

    $scope.remainTime = 5;

    var interval = setInterval(function () {
        if ($scope.remainTime > 0) {
            $timeout(function () {
                $scope.remainTime -= 1;
            });
        } else {
            $scope.goToPortal();
        }
    }, 1000);

    $scope.goToPortal = function () {
        interval && clearInterval(interval);
        yvNav.exit_app();
    };

}]);

ppmessageModule.controller("LoginNoUserCtrl", [
    "$scope",
    "$state",
    "$timeout",
    "yvNav",
    "yvMain",
    "yvLogin",
function ($scope, $state, $timeout, yvNav, yvMain, yvLogin) {


    $scope.user = {
        user_email: "",
        user_password: "",
    };

    $scope.$on("$ionicView.enter", function () {
        yvNav.clear();
        yvMain.set_server();
    });
    
    $scope.disableLogin = function () {
        if ($scope.user.user_email && $scope.user.user_password) {
            return false;
        }
        return true;
    };

    $scope.deviceUserLogin = function () {
        yvLogin.login({
            user_email: $scope.user.user_email,
            user_password: hex_sha1($scope.user.user_password)
        });
    };

}]);

ppmessageModule.controller("LoginWithUserCtrl", [
    "$scope",
    "$state",
    "$timeout",
    "$stateParams",
    "yvNav",
    "yvMain",
    "yvLink",
    "yvLogin",
function ($scope, $state, $timeout, $stateParams, yvNav, yvMain, yvLink, yvLogin) {

    $scope.user = {
        user_password: "",
        icon: $stateParams.icon,
        user_email: $stateParams.email || "",
        fullname: $stateParams.fullname || ""
    };

    
    if (!$scope.user.user_email) {
        yvNav.login_no_user();        
    }

    
    $scope.$on("$ionicView.enter", function () {
        yvNav.clear();
        yvMain.set_server();
    });

    
    $scope.nouser = function () {
        yvNav.login_no_user();        
    };


    $scope.disableLogin = function () {
        if ($scope.user.user_password) {
            return false;
        }
        return true;
    };

    
    $scope.getDeviceUserIcon = function () {
        return yvLink.get_user_icon($scope.user.icon);
    };

    
    $scope.deviceUserLogin = function () {
        yvLogin.login({
            user_email: $scope.user.user_email,
            user_password: hex_sha1($scope.user.user_password)
        });
    };

}]);

ppmessageModule.controller("AppCtrl", [
    "$scope",
    "yvDB",
    "yvLog",
    "yvSys",
    "yvNav",
    "yvBase",
    "yvLogin",
function ($scope, yvDB, yvLog, yvSys, yvNav, yvBase, yvLogin) {

    yvNav.clear();

    $scope.$on("event:reload", function (e, m) {
        yvNav.clear();
    });


    $scope.$on("$ionicView.unloaded", function () {
        
    });

    
    $scope.showNavButton = function () {
        if (window.innerWidth >= 768) {
            return false;
        }
        return true;
    };


    $scope.getUnread = function () {
        var sum = 0;
        var list = yvBase.get_list("conversation");
        angular.forEach(list, function (conversation) {
            sum += conversation.unread;
        });
        return sum > 99 ? "99+" : sum;
    };


    $scope.openSearchModal = function () {
        $scope.$broadcast("event:show-search-modal");
    };

}]);

ppmessageModule.controller("ConversationListCtrl", [
    "$scope",
    "$timeout",
    "$rootScope",
    "$stateParams",
    "yvLog",
    "yvSys",
    "yvAPI",
    "yvBase",
    "yvMain",
    "yvAlert",
    "yvLogin",
    "yvDelegate",
    "yvConstants",
function ($scope, $timeout, $rootScope, $stateParams, yvLog, yvSys, yvAPI, yvBase, yvMain, yvAlert, yvLogin, yvDelegate, yvConstants) {

    var content_delegate = yvDelegate.get_scroll_delegate("conversation-list-scroll");

    $scope.eableInfiniteScroll = true;
    $scope.canShowNoConversation = true;

    $scope.conversations = yvBase.get_scope("conversation");
    
    $scope.$on("$ionicView.beforeEnter", function (event, currentView) {
        yvLogin.check_session();
        if (yvSys.in_pc() && $stateParams.conv_uuid) {
            $timeout(function () {
                $rootScope.$broadcast("event:open-conversation", $stateParams);
            });
        }
    });
    
    $scope.showConversation = function (conversation) {
        if (!conversation.show) return false;
        return true;
    };

    $scope.loadMoreConversation = function () {
        var page = $scope.conversations.page + 1;
        var args = { "page_offset": page, "page_size": yvSys.page_size() };

        yvAPI.get_conversation_page(args, function (res) {
            if (res.list.length < yvSys.page_size()) {
                $scope.eableInfiniteScroll = false;
            }
            yvMain.add_conversation_from_api_reserve(res.list);
            $scope.$broadcast("scroll.infiniteScrollComplete");
            $scope.conversations.page = page;
        }, _load_error, _load_error);

        function _load_error() {
            $scope.eableInfiniteScroll = false;
            $scope.$broadcast("scroll.infiniteScrollComplete");
            yvAlert.tip("app.GLOBAL.CANT_GET_MORE_CONVERSATIONS");
            $timeout(function () {
                $scope.eableInfiniteScroll = true;
            }, 5000);
        }
    };
    
    $scope.refreshConversations = function () {
        $scope.canShowNoConversation = false;
        var promise = yvMain.update_conversations_from_server();

        promise.then(function () {
            yvDelegate.scroll_resize("conversation-list-scroll");
            if (yvSys.in_pc()) {
                $rootScope.$broadcast("event:open-conversation", null);
            }
        }, function () {
            yvAlert.tip("app.GLOBAL.CANT_REFRESH_CONVERSATIONS");
        });
        
        promise.finally(function () {
            $scope.eableInfiniteScroll = true;
            $scope.canShowNoConversation = true;
            $scope.$broadcast("scroll.refreshComplete");
        });
    };

    $scope.onScroll = function () {
    };
        
}]);

ppmessageModule.controller("ConversationCtrl", [
    "$scope",
    "$timeout",
    "$rootScope",
    "$stateParams",
    "$ionicLoading",
    "yvAPI",
    "yvSys",
    "yvLog",
    "yvMain",
    "yvNoti",
    "yvBase",
    "yvAlert",
    "yvLocal",
    "yvMessage",
    "yvDelegate",
    "yvConstants",
function ($scope, $timeout, $rootScope, $stateParams, $ionicLoading, yvAPI, yvSys, yvLog, yvMain, yvNoti, yvBase, yvAlert, yvLocal, yvMessage,
          yvDelegate, yvConstants) {

    var page_size = 12;
    $scope.inMobile = yvSys.in_mobile();
    $scope.chatStatus = { "status": yvConstants.CHAT_STATUS.NULL };

    _init_common();
    
    $scope.$on("$ionicView.beforeEnter", function () {
    });
    
    $scope.$on("$ionicView.enter", function () {
    });

    $scope.$on('$destroy', function () {
        yvBase.active("conversation", null);
        $scope.$broadcast("event:save-chat-text", $scope.conversation);
    });

    $scope.$on("event:open-conversation", function (event, params) {
        $scope.$broadcast("event:save-chat-text", $scope.conversation);
        $ionicLoading.show({duration: 5000});
        _init_core(params);
    });

    function _stop_loading() {
        $timeout(function () {
            yvDelegate.scroll_bottom("conversation-scroll", true);
        });
        $ionicLoading.hide();
    }

    function _init_common() {
        $scope.title = "";
        $scope.messages = [];
        $scope.valid = false;
        $scope.api_uuid = null;
        $scope.titleClass = "";
        $scope.conversation = {};
        $scope.timestamp = { "pre": 0};
        $scope.max_display_count = page_size;
    }

    function _init_valid (conversation) {
        $scope.valid = true;
        $scope.timestamp.pre = 0;
        $scope.titleClass = "arrow-down";
        $scope.api_uuid = yvSys.get_uuid();
        $scope.conversation = conversation;
        $scope.max_display_count = page_size;
        $scope.messages = conversation.messages;

        if (conversation.type === yvConstants.CONVERSATION_TYPE.S2S) {
            $scope.title = conversation.name;
        } else if (conversation.type === yvConstants.CONVERSATION_TYPE.P2S) {
            $scope.title = yvBase.get("object", conversation.user_uuid, "fullname");
        }
        
        _load_messages();
        yvMain.unread_zero(conversation);
        $scope.$broadcast("event:restore-chat-text", conversation);
    }
    
    function _init_core(params) {
        if (!params || !params.conv_uuid) {
            _init_common();
            _stop_loading();
            return;
        }
        var conversation = yvBase.get("conversation", params.conv_uuid);
        if (conversation === null) {
            _init_common();
            _stop_loading();
            return;
        }
        _init_valid(conversation);
    }

    function _load_messages() {
        var api_uuid = $scope.api_uuid;
        var conversation = $scope.conversation;
        var args = {
            "page_offset": 0,
            "page_size": page_size,
            "conversation_uuid": conversation.uuid
        };

        if (conversation.messages.length) {
            _stop_loading();
            return;
        }

        yvAPI.get_page_history_message(args, function (response) {
            angular.forEach(response.list, function (message) {
                conversation.messages.unshift(yvMessage.history_message(message));
            });
            conversation._refresh();
            if (api_uuid == $scope.api_uuid) {
                _stop_loading();
            }
        }, __get_local_messages, __get_local_messages);

        function __get_local_messages() {
            yvMain.load_conversation_messages(conversation, function (length) {
                if (api_uuid == $scope.api_uuid) {
                    _stop_loading();
                }
            });
        }
    }


    function _get_history_messages() {
        var api_uuid = $scope.api_uuid;
        var conversation = $scope.conversation;
        var args = { "page_size": page_size, "conversation_uuid": conversation.uuid };

        if (conversation.messages.length == 0) {
            args.page_offset = 0;
        } else {
            args.max_uuid = conversation.messages[0].task_uuid;
        }

        yvAPI.get_page_history_message(args, function (response) {
            var repeat_count = 0;
            angular.forEach(response.list, function (message) {
                message = yvMessage.history_message(message);
                if (conversation.has_message(message)) {
                    repeat_count += 1;
                    return;
                }
                message.disableScroll = true;
                conversation.messages.unshift(message);
            });

            conversation._refresh();
            
            if (api_uuid == $scope.api_uuid) {
                $scope.$broadcast("scroll.refreshComplete");
                $scope.max_display_count += response.list.length - repeat_count;                
                if (response.list.length == repeat_count) {
                    yvAlert.tip("app.GLOBAL.NO_MORE_HISTORY_MESSAGES");
                }
            }
        }, __error, __error);
        
        function __error() {
            if (api_uuid == $scope.api_uuid) {
                yvAlert.tip("app.GLOBAL.CANT_GET_MORE_HISTORY_MESSAGES");
            }
        }
    }


    $scope.showMessage = function (message) {
        var number = $scope.messages.length - $scope.messages.indexOf(message);
        return number <= $scope.max_display_count;
    };


    $scope.getContentBottomStyle = function () {
        var _s = $scope.chatStatus.status,
            _S = yvConstants.CHAT_STATUS,
            _b = 49;

        if (!$scope.conversation || !$scope.valid) {
            return {"bottom": "0px"};
        }

        if (yvSys.in_pc()) {
            return {"bottom": "180px"};
        }

        if (_s === _S.NULL) {
            return {"bottom": _b + "px"};
        }

        if (_s === _S.TEXTING) {
            return {"bottom": _b + "px"};
        }

        if (_s === _S.RECORDING_PRE || _s === _S.RECORDING || _s === _S.RECORDING_CANCEL || _s === _S.ADDING) {
            _b = _b + yvSys.get_keyboard_height();
            return {"bottom": _b + "px"};
        }

        return {"bottom": _b + "px"};
    };


    $scope.deleteMessage = function (message) {
        yvMain.delete_message($scope.conversation, message);
    };


    $scope.doRefresh = function () {
        $scope.timestamp.pre = 0;
        var difference = $scope.messages.length - $scope.max_display_count;

        if (difference <= 0) {
            _get_history_messages();
            return;
        }

        var increment = difference < page_size ? difference : page_size;
        $scope.max_display_count += increment;
        $scope.$broadcast("scroll.refreshComplete");
    };


    $scope.sendMessage = function (message) {
        yvMain.send_message($scope.conversation, message);
    };

    $scope.showImageModal = function (image) {
        $rootScope.$broadcast("event:show-image-modal", image);
    };

    $scope.showTextModal = function (content) {
        $rootScope.$broadcast("event:show-text-modal", content);
    };
    
}]);

ppmessageModule.controller("MessageCtrl", [
    "$scope",
    "$filter",
    "$sce",
    "yvDelegate",
function controller($scope, $filter, $sce, yvDelegate) {
    var self = this;

    self.isLast = $scope.isLast;
    
    self.scrollBottom = function () {
        if ($scope.isLast === true && !$scope.message.disableScroll) {
            yvDelegate.scroll_bottom();
        }
    };

    self.scrollDownByElement = function (element) {
        var height = getClientRectHeight(element);
        if ($scope.isLast === true || $scope.message.disableScroll) {
            return;
        }
        yvDelegate.scroll_down(height);
    };
    
    self.getTrustedText = function (rawText) {
        var newText = $filter("linky")(rawText, "_blank");
        return $sce.trustAsHtml(newText);
    };

    
    function getClientRectHeight(element) {
        var height = 0;
        if (element.getBoundingClientRect) {
            height = element.getBoundingClientRect().height;
        }
        return height;
    }
    
}]);

ppmessageModule.controller("ContactListCtrl", [
    "$scope",
    "$timeout",
    "$rootScope",
    "$stateParams",
    "yvSys",
    "yvUser",
    "yvLink",
    "yvBase",
    "yvLogin",
function ($scope, $timeout, $rootScope, $stateParams, yvSys, yvUser, yvLink, yvBase, yvLogin) {

    $scope.$on("event:reload", function () {
        _init();
    });

    
    $scope.$on("$ionicView.beforeEnter", function (event, currentView) {
        yvLogin.check_session();
    });

    
    $scope.showContact = function (contact) {
        if (contact.uuid === yvUser.get("uuid")) {
            return false;
        }
        return true;
    };

    
    function _init() {
        $scope.contacts = yvBase.get_list("contact");
        
        if (yvSys.in_pc()) {
            $timeout(function () {
                $rootScope.$broadcast("event:view-contact", $stateParams.contact_uuid);
            });
        }
        
    }

    _init();
}]);

ppmessageModule.controller("ContactCtrl", [
    "$scope",
    "$state",
    "$timeout",
    "$stateParams",
    "$rootScope",
    "yvSys",
    "yvLink",
    "yvMain",
    "yvUser",
    "yvBase",
    "yvConstants",
function ($scope, $state, $timeout, $stateParams, $rootScope, yvSys, yvLink, yvMain, yvUser, yvBase, yvConstants) {
    
    function openConversationCallback(conversation) {
        var params = {
            conv_uuid: conversation.uuid,
            conv_type: conversation.type,
            user_uuid: conversation.user_uuid
        };
        
        if (yvSys.in_pc()) {
            $state.go("app.conversation-list", params);
        } else {
            $state.go("app.conversation-list-mobile");
            $timeout(function () {
                $state.go("app.conversation-mobile", params);
            });
        }
    }

    $scope.createServiceUser = function($event) {
        $rootScope.$broadcast("event:add-service-user-modal");
    };
    
    $scope.chatWithContact = function () {
        var params = {
            member_list: [$scope.contact.uuid],
            conversation_name: $scope.contact.fullname,
            conversation_type: yvConstants.CONVERSATION_TYPE.S2S,
        };
        
        yvMain.open_conversation(params, openConversationCallback);
    };
    
    
    $scope.getIcon = function () {
        var icon = yvBase.get("object", $scope.contact.uuid, "icon");
        return yvLink.get_user_icon(icon);
    };

    
    $scope.$on("event:view-contact", function (event, _uuid) {
        _init(_uuid);
    });

    
    function _init(_contact_uuid) {
        if (_contact_uuid) {
            $scope.contact = yvBase.get("contact", _contact_uuid);
        } else {
            $scope.contact = {};
        }
    }

    _init($stateParams.contact_uuid);
}]);

ppmessageModule.controller("SettingListCtrl", [
    "$scope",
    "$state",
    "yvSys",
    "yvUser",
    "yvLink",
    "yvLogin",
    "yvLogout",
function ($scope, $state, yvSys, yvUser, yvLink, yvLogin, yvLogout) {

    $scope.$on("$ionicView.beforeEnter", function (event, currentView) {
        yvLogin.check_session();
    });
    

    $scope.logoutDeviceUser = function () {
        yvLogout.logout();
    };


    $scope.getDeviceUserIcon = function () {
        return yvLink.current_user_avatar();
    };

    
    $scope.getDeviceUserFullName = function () {
        return yvUser.get("fullname");
    };

    
    $scope.getSignature = function () {
        return yvUser.get("signature");
    };

    
    $scope.changeAvatar = function () {        
        $state.go("app.change-avatar");
        return;
    }
    

    $scope.showImageModal = function () {
        var remove = $scope.$on("$stateChangeStart", function (event) {
            event.preventDefault();
            $scope.$broadcast("event:show-image-modal");
            remove();
        });
    };
}]);

ppmessageModule.controller("SwitchLanguageCtrl", [
    "$scope",
    "$state",
    "$timeout",
    "$ionicHistory",
    "yvNav",
    "yvSys",
    "yvAlert",
    "yvLocal",
function ($scope, $state, $timeout, $ionicHistory, yvNav, yvSys, yvAlert, yvLocal) {
    
    function _select_cb(language) {
        $scope.active_language = language;
        yvAlert.success();
    }

    
    function _init_cb(language) {
        language = yvLocal.filter_language(language);
        angular.forEach($scope.languageList, function (lang) {
            if (lang.language === language) {
                $scope.active_language = lang.language;
                lang.is_selected = true;
            }
        });
    }

    
    $scope.select = function (language) {
        if ($scope.active_language === language.language) {
            return;
        }
        
        yvLocal.localize_by_language(language.language);
        _select_cb(language.language);
    };

    
    function _init() {
        $scope.languageList = [
            {display_name: "app.settings.language.ENGLISH_TAG", language: "en", is_selected: false},
            {display_name: "app.settings.language.CHINESE_TAG", language: "zh-Hans", is_selected: false}
        ];
                
        yvLocal.get_current_language(_init_cb);
    }

    _init(); 
    
}]);

ppmessageModule.controller("AboutCtrl", [
    "$scope",
    "$filter",
    "yvSys",
function ($scope, $filter, yvSys) {
    
        
    $scope.getButtonText = function () {
        var text = $filter("translate")($scope.button_text);
        if (!$scope.is_newest && $scope.newest_version) {
            return text + $scope.newest_version;
        }
        return text;
    };

    
    $scope.showUpdateButton = function () {
        if (yvSys.in_browser()) {
            return false;
        }
        return true;
    };

    
    function _handle_version_data(data) {
        $scope.plist_url = data.plist_url;
        $scope.download_url = data.download_url;
        $scope.newest_version = data.newest_version;
    }

    
    function _check_version() {
    }

    
    function _init() {
        $scope.is_newest = true;
        $scope.button_text = "";
        $scope.local_version = "";
        $scope.newest_version = "";
        $scope.app_name = yvSys.get_bundle_info().display_name;
        
        $scope.local_version = "v" + ppmessage.version;
    }

    _init();
    
}]);

ppmessageModule.controller("ChangePasswordCtrl", [
    "$scope",
    "$ionicHistory",
    "yvDB",
    "yvAPI",
    "yvUser",
    "yvAlert",
    "yvConstants",
function ($scope, $ionicHistory, yvDB, yvAPI, yvUser, yvAlert, yvConstants) {

    $scope.password = {};
    $scope.password.old = "";
    $scope.password.new0 = "";
    $scope.password.new1 = "";
    
    var _password = function(_password) {
        var _d = yvAPI.update_user({ user_password:_password }, function() {
            yvUser.set("password", _password);
            yvAlert.success();
            $ionicHistory.goBack();
        }, function() {
            yvAlert.fail();
        }, function() {
            yvAlert.fail();
        });
    };

    $scope.save = function() {
        var origin_password = yvUser.get("password");
        if ($scope.password.old.length  == 0  ||
            $scope.password.new0.length == 0  ||
            $scope.password.new1.length == 0) {
            yvAlert.tip("app.changepwdctrl.PROMPT_EMPTY");
            return;
        }
        if (hex_sha1($scope.password.old) != origin_password) {
            yvAlert.tip("app.changepwdctrl.PROMPT_PWD_ERROR");
            return;
        }
        
        if ($scope.password.new0 != $scope.password.new1) {
            yvAlert.tip("app.changepwdctrl.PROMPT_VERIFY_ERROR");
        } else if ($scope.password.new0 == origin_password) {
            yvAlert.tip("app.changepwdctrl.PROMPT_SAME_ERROR");
        } else if ($scope.password.new0.length > 16) {
            yvAlert.tip("app.changepwdctrl.PROMPT_LENGTH");
        } else {
            _password(hex_sha1($scope.password.new0));
        }
    };

}]);

ppmessageModule.controller("ChangeAvatarCtrl", [
    "$scope",
    "$timeout",
    "FileUploader",
    "$ionicLoading",
    "yvSys",
    "yvAPI",
    "yvUser",
    "yvMain",
    "yvFile",
    "yvLocal",
    "yvDelegate",
function ($scope, $timeout, FileUploader, $ionicLoading, yvSys, yvAPI, yvUser, yvMain, yvFile, yvLocal, yvDelegate) {

    /* This Controller is intended to work in pc-browser, mobile-browser, electron, NOT INCLUDING mobile-native !
     * It must be used together with directive: yvCropImage.
     */
    
    var fileItem = null;
    var reader = new FileReader();

    $scope.imgSrc = null;
    $scope.isDirty = false;
    $scope.uploader = new FileUploader();
    $scope.uploaderOptions = {
        url: yvAPI.get_server().upload_url,
        formData: [{ "user_uuid": yvUser.get("uuid") }]
    };
    
    reader.onloadstart = onReaderLoadStart;
    reader.onprogress = onReaderProgress;
    reader.onloadend = onReaderLoadEnd;
    reader.onload = onReaderLoad;

    $scope.uploader.onAfterAddingFile = onAfterAddingFile;
    $scope.uploader.onSuccessItem = onSuccessItem;
    $scope.uploader.onErrorItem = onErrorItem;

    $scope.$on("event:set-dirty", setDirty);

    function onReaderLoadStart(event) {
        var text = yvLocal.translate("app.settings.profile_photo.LOADING_TAG");
        var template = "<p>" + text + "</p>";
        $ionicLoading.show({
            delay: 100,
            scope: $scope,
            duration: 10000,
            noBackdrop: true,
            template: template
        });
    }


    function onReaderLoadEnd(event) {
        $ionicLoading.hide();
    }


    function onReaderLoad(event) {
        $timeout(function () {
            $scope.imgSrc = event.target.result;
        });
    }


    function onReaderProgress(event) {
        //CR: Show progress bar, necesarry in mobile browser
        return;
    }

    // return true if reader is loading...
    function abortActiveReader(reader) {
        if (reader && reader.readyState === FileReader.LOADING) {
            reader.abort();
            return true;
        }
        return false;
    }


    function onAfterAddingFile(item) {
        if (!reader) {
            return;
        }
        fileItem = item;
        abortActiveReader(reader);
        reader.readAsDataURL(item._file);
        return;
    }


    function onSuccessItem(item, response, status, headers) {
        if (item !== fileItem) {
            return;
        }
        var fid = response.fuuid;
        yvAPI.update_user({ user_icon: fid }, function (res) {
            yvMain.update_current_user("icon", fid);
            $scope.restore();
        });
    }


    function onErrorItem(item, response, status, headers) {
        console.error("upload item error", item, response);
    }


    function cropAvatarCallback(blob) {
        if (!fileItem) {
            return;
        }
        fileItem._file = blob;
        fileItem.upload();
        return;
    }


    function restoreAvatarCallback() {
        $scope.imgSrc = null;
        abortActiveReader(reader);
        $scope.uploader.clearQueue();
        yvDelegate.scroll_top("change-avatar", true);
    }


    function setDirty(event, bool) {
        event.stopPropagation();
        if ($scope.isDirty === !bool) {
            $timeout(function () {
                $scope.isDirty = bool;
            });
        }
    }

    
    $scope.choosePhoto = function () {
        // CR: If is loading, pop up a confirm modal
        if (abortActiveReader(reader)) {
            return;
        }
        if (yvSys.in_browser() || yvSys.in_electron()) {
            var input = document.querySelector("input#upload-avatar");
            input && input.click();
            return;
        }
        return;
    };


    // save avatar
    $scope.save = function () {
        $scope.$broadcast("event:crop-avatar", cropAvatarCallback);
    };

    
    // restore current avatar
    $scope.restore = function () {
        $scope.$broadcast("event:restore-avatar", restoreAvatarCallback);
    };

}]);

ppmessageModule.controller("ChangeFullnameCtrl", [
    "$scope",
    "$ionicHistory",
    "yvAPI",
    "yvUser",
    "yvMain",
    "yvAlert",
    "yvConstants",
function ($scope, $ionicHistory, yvAPI, yvUser, yvMain, yvAlert, yvConstants) {

    $scope.fullname = {};
    $scope.fullname.text = yvUser.get("fullname");

    var _fullname  = function(_name) {
        var _d = yvAPI.update_user({user_fullname: _name}, function(data) {
            yvMain.update_current_user("fullname", _name);
            yvAlert.success();
            $ionicHistory.goBack();
        }, function() {
            yvAlert.fail();
        }, function() {
            yvAlert.fail();
        });
    };

    $scope.shouldShowSave = function() {
        if ($scope.fullname.text.length == 0) {
            return true;
        }
        return false;
    };
    
    $scope.save = function() {
        var _nameLen = $scope.fullname.text.length;
        var _alert = "";
        
        if (_nameLen == 0) {
            yvAlert.tip("app.changefullnamectrl.FULLNAME_EMPTY");
            return;
        }
        
        if (_nameLen > 32) {
            yvAlert.tip("app.changefullnamectrl.FULLNAME_TOO_LARGE");
            return;
        }
        
        if (_nameLen > 0 && _nameLen <= 32) {
            _fullname($scope.fullname.text);
            return;
        }
        return;
    };
    
}]);

ppmessageModule.controller("ChangeSignatureCtrl", [
    "$scope",
    "$ionicLoading",
    "$ionicHistory",
    "yvSys",
    "yvAPI",
    "yvUser",
    "yvMain",
    "yvLocal",
function ($scope, $ionicLoading, $ionicHistory, yvSys, yvAPI, yvUser, yvMain, yvLocal) {

    $scope.data = {
        signature: yvUser.get("signature") || ""
    };

    
    function _show_loading(template) {
        $ionicLoading.show({
            duration: 1000,
            noBackdrop: true,
            template: yvLocal.translate(template)
        });       
    }
    
    
    function _error() {
        _show_loading("app.GLOBAL.UPDATE_FAILED");
    }

    
    $scope.save = function () {
        var signature = $scope.data.signature;
        yvAPI.update_user({user_signature: signature}, function(data) {
            yvMain.update_current_user("signature", signature);
            _show_loading("app.GLOBAL.UPDATE_SUCCESS");
            if (yvSys.in_mobile()) {
                $ionicHistory.goBack();
            }
        }, _error, _error);
    };

    
    $scope.disableSave = function () {
        var signature = $scope.data.signature;      
        if ((signature && signature.length > 50) || signature === yvUser.get("signature")) {
            return true;
        }
        return false;
    };
    
}]);

ppmessageModule.controller("DeveloperKeysCtrl", [
    "$scope",
    "$timeout",
    "yvAPI",
    "yvUser",
    "yvMain",
function ($scope, $timeout, yvAPI, yvUser, yvMain) {

    $scope.keys = {
        app_uuid: yvUser.get("app").uuid,
        ppcom: {
            api_key: null,
            api_secret: null
        }        
    };

    yvAPI.request("/PP_GET_API_INFO", {user_uuid: yvUser.get("uuid")}, function(response) {
        $timeout(function() {
            $scope.keys.ppcom.api_key = response.ppcom.api_key;
            $scope.keys.ppcom.api_secret = response.ppcom.api_secret;
        });
    });
        
}]);

ppmessageModule.controller("WidgetCodeCtrl", [
    "$scope",
    "yvUser",
function ($scope, yvUser) {

    $scope.data = {
        widget_code : _generate_enterprise_code()
    };
    
    function _generate_enterprise_code() {
        var _code = "<script> window.ppSettings = {app_uuid:'{{app_uuid}}'};" +
            "(function(){" +
            "var w=window,d=document;" +
            "function l(){" +
            "var a=d.createElement('script');" +
            "a.type='text/javascript';" +
            "a.async=!0;" +
            "a.src='{{server_url}}/ppcom/assets/pp-library.min.js';" +
            "var b=d.getElementsByTagName('script')[0];" +
            "b.parentNode.insertBefore(a,b)" +
            "}" +
            "l();" +
            "})();" +
            "</script>";
        
        return _code.replace("{{app_uuid}}", yvUser.get("app").uuid)
            .replace("{{server_url}}", window.ppmessage.server_url);
    }
    
}]);

ppmessageModule.controller("WidgetLinkCtrl", [
    "$scope",
    "yvUtil",
    "yvUser",
function ($scope, yvUtil, yvUser) {

        
    $scope.data = {
        widget_link: _generate_enterprise_link()
    };

    
    $scope.lookNow = function() {
        window.open($scope.data.widget_link, "_blank");
    };
    
    function _generate_enterprise_link() {
        // `base64_encode` only accept `255 ascii` characters, so we need `escape` here
        var _appObj = {
            uuid: yvUser.get("app").uuid,
            app_name: encodeURI(yvUser.get("app").app_name || '')
        }; 
        var _param = yvUtil.base64_encode(JSON.stringify(_appObj));

        var _link_template = "{{server_url}}/ppcom/enterprise/{{app_signature}}";
        return _link_template
            .replace("{{server_url}}", window.ppmessage.server_url)
            .replace("{{app_signature}}", _param);
    }

}]);

angular.element(document).ready(function() {
    angular.bootstrap(document, ["ppmessage"]);
    console.log("booted");
});
